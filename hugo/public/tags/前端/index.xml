<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>前端 on 指尖魔法屋</title>
    <link>https://blog.thinkmoon.cn/tags/%E5%89%8D%E7%AB%AF/</link>
    <description>Recent content in 前端 on 指尖魔法屋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© 2025 ThinkBlog. All rights reserved.</copyright>
    <lastBuildDate>Mon, 12 Dec 2022 22:11:09 +0000</lastBuildDate>
    <atom:link href="https://blog.thinkmoon.cn/tags/%E5%89%8D%E7%AB%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Vue3使用customRef()主动触发响应更新</title>
      <link>https://blog.thinkmoon.cn/post/975_vue3%E4%BD%BF%E7%94%A8customref__%E4%B8%BB%E5%8A%A8%E8%A7%A6%E5%8F%91%E5%93%8D%E5%BA%94%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Mon, 12 Dec 2022 22:11:09 +0000</pubDate>
      <guid>https://blog.thinkmoon.cn/post/975_vue3%E4%BD%BF%E7%94%A8customref__%E4%B8%BB%E5%8A%A8%E8%A7%A6%E5%8F%91%E5%93%8D%E5%BA%94%E6%9B%B4%E6%96%B0/</guid>
      <description>前言 在vue3中（尤其是setup语法）vue框架会自动处理事件响应。但是假设有个场景，我们实现了一个数据结构，只要触发对应操作时，就刷新视图。这个问题在选项式API有个公共API，提供强制刷新能力，那就是$forceUpdate()。$forceUpdate()会全量刷新，而且组合式API不支持该方法，这个时候如果我们想主动触发视图更新，可以使用Vue3提供的customRef()自定义一个ref。&#xA;介绍 customRef()，创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。&#xA;形如&#xA;function customRef&amp;lt;T&amp;gt;(factory: CustomRefFactory&amp;lt;T&amp;gt;): Ref&amp;lt;T&amp;gt; type CustomRefFactory&amp;lt;T&amp;gt; = ( track: () =&amp;gt; void, trigger: () =&amp;gt; void ) =&amp;gt; { get: () =&amp;gt; T set: (value: T) =&amp;gt; void } 其中，track函数告诉框架这是一个需要追踪变更的变量，一般在get里面调用。trigger则是数据变化时调用，用以通知框架，该变量已发生变化触发视图更新。&#xA;示例 实现一个日志展示功能，当日志增加时，触发视图更新&#xA;这是一个简陋的日志系统，永远展示最后十条日志(截图少了个.slice(-10))。而且我在程序最后加了个定时器，每隔一秒定时增加一条日志。&#xA;从图中的结果可以发现，对应的数据变化并未相应的渲染在视图上。这个使用我们就需要customRef实现一个自定义的ref，当日志增加时主动触发trigger通知视图更新&#xA;使用customRef改造 总结 使用customRef的好处就是可以把trigger暴露到外部，直接触发trigger就会触发刷新，实现按需加载的效果。</description>
    </item>
    <item>
      <title>如何理解Promise</title>
      <link>https://blog.thinkmoon.cn/post/956_%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3promise/</link>
      <pubDate>Fri, 09 Dec 2022 21:35:49 +0000</pubDate>
      <guid>https://blog.thinkmoon.cn/post/956_%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3promise/</guid>
      <description>Promise是啥？异步函数？对象？怎么用才更自信？如何理解更好的理解Promise？本文将分享本人对于Promise的一些经验与想法。&#xA;背景知识 此段将介绍一些理解本文的背景知识，你可以很轻松愉快的阅读此段。&#xA;函数是一等公民 总所周知，在JavaScript里面，函数是一等公民。你可以用来赋值，传参，回调，包装，作为函数返回值return。&#xA;以下内容援引于JavaScript 为什么说函数是一等公民？&#xA;函数与数字一样可以存储到变量中 var fortyTwo = 42 var fortyOne = function() { return 41; } 函数与数字一样可以存储为数组的一个元素 var nums = [42, function() { return 41 }] 函数与数字一样可以在使用时直接创建出来 42 + (fuction() { return 41 })(); // 83 函数与数字一样可以被传递给另一个函数 function weirdAdd( n, fun) { return n + fun()} weirdAdd(42, function() { return 41 }) 函数与数字一样可以被另一个函数返回 function add() { var num1 = 42; return function(num2) { return num1 + num2 } } fun = add(); fun(41); // 83 函数就是变量，变量可以存放函数。就是玩~</description>
    </item>
    <item>
      <title>前端模块化</title>
      <link>https://blog.thinkmoon.cn/post/943_%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Wed, 15 Jun 2022 00:00:02 +0000</pubDate>
      <guid>https://blog.thinkmoon.cn/post/943_%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>什么是模块化？ 在程序设计领域，模块就是为完成某一个功能的一段程序或者子程序&#xA;一个文件可以是一个模块，一个文件夹也可以是一个模块。模块的思想完美的符合了设计模式中的单一职责原则。只做一件事，或者一类事，分清任务的边界。&#xA;为什么需要模块化？ 模块化的目的是将任务细分，在现阶段的软件工程阶段，模块化的方式可以将一个大任务分给不同的人或组织，每个人所负责的模块相对独立而又互为依存关系。而在开源领域和工程复用阶段，模块化可以让我们更方便的站在人民群众的肩膀上，众人拾薪柴火高。使我们可以更多的关注业务逻辑，而不用过分在意实现细节。&#xA;现阶段前端有哪些模块化方式？ 现阶段前端模块化规范有这几种，AMD（Asynchronous Module Definition，CMD（Common Module Definition），CommonJs，Es6 Moduel；&#xA;AMD(require.js) AMD规范如其全名一致，异步模块定义。是require.js 在推广过程中对模块化定义的规范产出的。它的主要思想是前置依赖，让依赖先加载和执行，然后再之后后面的语句。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，才会运行这个回调函数。&#xA;CMD(sea.js) CMD与AMD规范不一样，AMD是一种与预加载的方式，否管你有没有用到，先把依赖加载进来执行了再说。而CMD是按需依赖的形式，你先运行把，运行到哪里了缺啥你再告诉我，我给你按需依赖。&#xA;Commonjs CommonJs，运行时加载，理论上来说，这个规范一般都是用于服务端的node环境，与前端可能相关性不大，但是作为Js的模块化规范的几大巨头之一，我们也应该了解其思想和实现逻辑。CommonJs模块都是对象，先读取加载整个模块，生成一个对象，然后再从这个对象上面读取方法。由于它是读取后深拷贝（对值的拷贝）这个时候你再进行模块内部变量的改变，是不会影响原依赖模块的使用。CommonJs是同步加载的，一般同步就意味着等待，而有效等待的前提就需要良好的运行环境，这在浏览器上变换莫测的网络环境显然是没法满足的，一个404的js，就造成页面的长时间等待。所以这个规范一般被用作服务端node环境。&#xA;ES6 module 在我学前端的心路历程中，但凡跟ES6扯上关系的，总得带点牛逼气息，ES6 module也是如此，它是从语言层面定义的模块化解决方案。ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。&#xA;我该用哪种模块化方式？ 答：当然是最牛逼的&#xA;理想上，我们应该全部使用ES6 module这种牛逼的方式。但是理想与现实总是存在着略微的差距，虽然我们平常写Vue组件，ES6 module 用得是肆无忌惮，风生水起。但这并不意味着我们现在生产环境上用的就是这个模式，所见有时并非所得。一方面并非所有的浏览器都能够支持ES6 module，另一方面则是由于，现如今磅礴的前端生态环境，巨额的嵌套引用入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。实际上当我们run build时，聪明的打包器帮我们完成一系列操作，tree-shaking、懒加载和 chunk 分割（以获得更好的缓存），让我们以最淳朴的形式表现于浏览器，当真是反哺归真。&#xA;参考文档 为什么选 Vite&#xA;前端模块化&#xA;模块设计术语</description>
    </item>
    <item>
      <title>js使用装饰器实现操作前二次确认询问</title>
      <link>https://blog.thinkmoon.cn/post/900_js%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E5%89%8D%E4%BA%8C%E6%AC%A1%E7%A1%AE%E8%AE%A4%E8%AF%A2%E9%97%AE/</link>
      <pubDate>Sun, 20 Sep 2020 13:18:57 +0000</pubDate>
      <guid>https://blog.thinkmoon.cn/post/900_js%E4%BD%BF%E7%94%A8%E8%A3%85%E9%A5%B0%E5%99%A8%E5%AE%9E%E7%8E%B0%E6%93%8D%E4%BD%9C%E5%89%8D%E4%BA%8C%E6%AC%A1%E7%A1%AE%E8%AE%A4%E8%AF%A2%E9%97%AE/</guid>
      <description>引言 相信大家平常在开发过程中，经常会遇到此类需求。危险操作（如删除，退出登录）往往需要弹框提示给用户二次确认一下。本文介绍的是，如何使用js方法装饰器，封装二次确认弹框操作，增加小伙伴的开发效率。&#xA;装饰器介绍 装饰器是对类、函数、属性之类的一种装饰，可以针对其添加一些额外的行为。详细使用，自行百度！&#xA;常规手段 view&#xA;&amp;lt;div class=&amp;#34;bg-white flex justify-center&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;btn-primary&amp;#34; @click=&amp;#34;clickMe&amp;#34;&amp;gt;点我&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; js&#xA;clickMe() { uni.showModal({ title: &amp;#34;点击提示&amp;#34;, content: &amp;#34;你确定要点我？&amp;#34;, success: (res) =&amp;gt; { if (res.confirm) { console.log(&amp;#34;点我干啥&amp;#34;); } }, }); } 效果展示&#xA;装饰器写法 confirm.js&#xA;function confirm(message: string, title: string, cancelFn = function() {}) { return function(target: any, name: string, descriptor: any) { const originFn = descriptor.value; descriptor.value = function(rest: any) { uni.showModal({ title: title, content: message, success: (res) =&amp;gt; { if (res.</description>
    </item>
    <item>
      <title>Vue环境变量和模式</title>
      <link>https://blog.thinkmoon.cn/post/894_vue%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 12 Aug 2020 15:54:15 +0000</pubDate>
      <guid>https://blog.thinkmoon.cn/post/894_vue%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E6%A8%A1%E5%BC%8F/</guid>
      <description>Vue环境变量和模式 我最开始使用vue的判断环境的方法是&#xA;let BASE_URL = process.env.NODE_ENV == &amp;#34;development&amp;#34; ? &amp;#34;http:/localhost&amp;#34; : &amp;#34;xxx&amp;#34; 在这种情况下，需要先判断它的编译环境，进而根据环境适用对应的值。如果只有一个地方的变量跟环境有关，情况还好。但是若有多个，则需要复制多个判断或者封装成一个方法。但也只能使用于两个环境，如果存在多个环境，诸如开发，测试，预发布，正式等环境，这个方法就捉襟见肘了。所以，我们需要设置Vue环境变量和模式，好像webpack也可以实现？（好吧，这不是重点）&#xA;实现方式 vue允许你在项目根目录下添加.env.[mode]的文件来指定环境变量。&#xA;.env # 在所有的环境中被载入 .env.local # 在所有的环境中被载入，但会被 git 忽略 .env.[mode] # 只在指定的模式中被载入 .env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略 比如我，我添加了.env.local,.env.development,.env.test,.env.production等文件，.env.local文件内容如下。&#xA;.env.local&#xA;VUE_APP_BUILD_MODE = &amp;#39;development&amp;#39; VUE_APP_BASE_URL = &amp;#39;http://172.16.6.132:8002/threemiju/&amp;#39; 对应package.json的script如下:&#xA;&amp;#34;scripts&amp;#34;: { &amp;#34;serve&amp;#34;: &amp;#34;vue-cli-service serve --mode&amp;#34;, &amp;#34;serve:test&amp;#34;: &amp;#34;vue-cli-service serve --mode test&amp;#34;, &amp;#34;build:test&amp;#34;: &amp;#34;vue-cli-service build --mode test&amp;#34;, &amp;#34;build:production&amp;#34;: &amp;#34;vue-cli-service build --mode production&amp;#34;, &amp;#34;deploy:test&amp;#34;: &amp;#34;git push &amp;amp;&amp;amp; git push gitlab dev &amp;amp;&amp;amp; vue-cli-service build --mode test&amp;#34; }, 请注意，此处有一个坑。当你使用yarn run build:test的时候，你会发现，假如你使用了异步组件，却会神奇的发现，它并没有把把代码切割，只编译成了一个app.</description>
    </item>
    <item>
      <title>el-upload视频上传支持回显和预览的一种异教徒解决方案</title>
      <link>https://blog.thinkmoon.cn/post/861_el-upload%E8%A7%86%E9%A2%91%E4%B8%8A%E4%BC%A0%E6%94%AF%E6%8C%81%E5%9B%9E%E6%98%BE%E5%92%8C%E9%A2%84%E8%A7%88%E7%9A%84%E4%B8%80%E7%A7%8D%E5%BC%82%E6%95%99%E5%BE%92%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Thu, 18 Jun 2020 11:28:57 +0000</pubDate>
      <guid>https://blog.thinkmoon.cn/post/861_el-upload%E8%A7%86%E9%A2%91%E4%B8%8A%E4%BC%A0%E6%94%AF%E6%8C%81%E5%9B%9E%E6%98%BE%E5%92%8C%E9%A2%84%E8%A7%88%E7%9A%84%E4%B8%80%E7%A7%8D%E5%BC%82%E6%95%99%E5%BE%92%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>该文章为异教徒解决方案，各位看官看下即可，切勿模仿！！！&#xA;问题描述 原生的el-upload只支持上传图片时候的预览和回显，这是因为只针对img标签做了适配，如下图。&#xA;而如果我们上传视频，则会出现一个白方框，用户体验不佳。&#xA;解决思路 其实正确的解决思路应该是&#xA;将show-file-list属性设置为false。然后再自己循环显示file-list，以及追加对应的预览，删除按钮及功能。&#xA;设置自定义模板内容(推荐使用)&#xA;但是我觉得这样太麻烦了(时间问题）。&#xA;于是我突发奇想，如果我将img标签改成video标签呢？如下图&#xA;发现居然完美契合，毫无违和感。&#xA;预览的实现 在做到把img改为video标签之前，还需要解决的另一个问题就是，如何让视频也支持预览。老规矩，我们先来看看官方Demo怎么实现预览的。&#xA;官方的做法是增加一个dialog，然后在点击预览图片时将文件url传给dialog。我们先来实现一下改写一下dialog&#xA;&amp;lt;el-dialog :visible.sync=&amp;#34;dialogVisible&amp;#34; :modal-append-to-body=&amp;#34;true&amp;#34;&amp;gt; &amp;lt;video width=&amp;#34;100%&amp;#34; muted autoplay=&amp;#34;autoplay&amp;#34; loop=&amp;#34;loop&amp;#34; v-if=&amp;#34;dialogImageUrl[dialogImageUrl.length - 1] == 4&amp;#34; :src=&amp;#34;dialogImageUrl&amp;#34;&amp;gt;&amp;lt;/video&amp;gt; &amp;lt;img width=&amp;#34;100%&amp;#34; v-else :src=&amp;#34;dialogImageUrl&amp;#34; alt /&amp;gt; &amp;lt;/el-dialog&amp;gt; tips: 我这种判断MP4格式的方式实属异端，不建议模仿。&#xA;替换img标签 一到标签节点的操作，我第一想到的就是document操作（异端+1），直接上代码。&#xA;changeVideoTag(){ let videoTag = document.querySelector(&amp;#39;.video img&amp;#39;) console.log(&amp;#39;检测到应为video的img标签&amp;#39;, videoTag) if(videoTag){ let parentNode = videoTag.parentNode let newElement = document.createElement(&amp;#39;video&amp;#39;) newElement.setAttribute(&amp;#39;class&amp;#39;, videoTag.getAttribute(&amp;#39;class&amp;#39;)) newElement.setAttribute(&amp;#39;src&amp;#39;, videoTag.getAttribute(&amp;#39;src&amp;#39;)) parentNode.insertBefore(newElement, videoTag) } }, 该函数负责寻找video类下的img标签，然后在img标签之前，添加一个同样的videos元素节点，此处你可以选择是否移除原img标签。&#xA;最终实现效果 最后的话 这种方法非常不推荐使用，强烈建议使用自定义模板缩略图&#xA;这种方法非常不推荐使用，强烈建议使用自定义模板缩略图</description>
    </item>
  </channel>
</rss>
