<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>学习笔记 on 指尖魔法屋</title>
    <link>http://localhost:1313/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
    <description>Recent content in 学习笔记 on 指尖魔法屋</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>© 2025 ThinkBlog. All rights reserved.</copyright>
    <lastBuildDate>Mon, 29 Sep 2025 14:19:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>探索 Python 的 Typing 库：增强代码健壮性</title>
      <link>http://localhost:1313/post/988-%E6%8E%A2%E7%B4%A2-python-%E7%9A%84-typing-%E5%BA%93%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%A0%81%E5%81%A5%E5%A3%AE%E6%80%A7/</link>
      <pubDate>Mon, 29 Sep 2025 14:19:00 +0000</pubDate>
      <guid>http://localhost:1313/post/988-%E6%8E%A2%E7%B4%A2-python-%E7%9A%84-typing-%E5%BA%93%E5%A2%9E%E5%BC%BA%E4%BB%A3%E7%A0%81%E5%81%A5%E5%A3%AE%E6%80%A7/</guid>
      <description>探索 Python 的 Typing 库：增强代码健壮性 Python 的 typing 库自 Python 3.5 引入，为动态类型的 Python 带来了静态类型注解功能，使开发者能够编写更健壮、可维护的代码。本文将深入探讨 typing 模块的主要功能、优势以及实用示例。&#xA;为什么使用类型注解？ 类型注解通过明确声明变量、函数参数和返回值的预期类型，提升了代码的可读性、可维护性和可靠性。它们支持像 mypy 这样的静态类型检查工具，在运行前捕获潜在错误。此外，类型注解还能增强 IDE 对自动补全和重构的支持，提高开发效率。&#xA;开始使用 Typing 库 typing 模块提供了丰富的工具来定义类型注解。以下是一些常用功能的介绍。&#xA;基本类型注解 类型注解可用于变量、函数参数和返回值，语法简单直观。&#xA;from typing import List, Dict # 变量注解 name: str = &amp;#34;Alice&amp;#34; age: int = 30 # 带类型注解的函数 def greet(person: str) -&amp;gt; str: return f&amp;#34;你好，{person}！&amp;#34; 在此例中，name 声明为 str 类型，age 为 int 类型，greet 函数接受一个 str 参数并返回一个 str。使用 mypy 等静态类型检查工具可以确保类型使用正确。&#xA;集合类型的复杂注解 typing 模块支持对列表、字典和元组等集合类型的复杂注解。&#xA;from typing import List, Dict, Tuple # 整数列表 numbers: List[int] = [1, 2, 3, 4] # 字符串键和浮点值字典 scores: Dict[str, float] = {&amp;#34;Alice&amp;#34;: 95.</description>
    </item>
    <item>
      <title>武林秘籍--docker篇</title>
      <link>http://localhost:1313/post/984_%E6%AD%A6%E6%9E%97%E7%A7%98%E7%B1%8D/</link>
      <pubDate>Mon, 03 Mar 2025 23:26:31 +0000</pubDate>
      <guid>http://localhost:1313/post/984_%E6%AD%A6%E6%9E%97%E7%A7%98%E7%B1%8D/</guid>
      <description>Docker 列出所有的容器 docker ps -a&#xA;列出所有的镜像 docker images 从镜像中简单启动一个容器 docker run -it node:22.14.0 /bin/bash 从宿主机中复制文件 docker cp C:\\Users\\YourUsername\\myfolder my-container:/app docker进入容器 docker attach my_container 启动容器 docker start my_container 将镜像推送到Registry docker login --username=13433616623 crpi-93tge61gwe5cjd70.cn-shenzhen.personal.cr.aliyuncs.com docker tag [ImageId] crpi-93tge61gwe5cjd70.cn-shenzhen.personal.cr.aliyuncs.com/docker_thinkmoon/api-collect:[镜像版本号] docker push crpi-93tge61gwe5cjd70.cn-shenzhen.personal.cr.aliyuncs.com/docker_thinkmoon/api-collect:[镜像版本号] 从Registry中拉取镜像 docker pull crpi-93tge61gwe5cjd70.cn-shenzhen.personal.cr.aliyuncs.com/docker\_thinkmoon/api-collect:\[镜像版本号] 容器打包成镜像 docker commit [容器名] [镜像名]:[标签]&#xA;镜像保存为文件 docker save -o &amp;lt;tar文件名&amp;gt;.tar &amp;lt;镜像名称&amp;gt;:&amp;lt;标签&amp;gt;&#xA;从文件中加载镜像 docker load -i &amp;lt;tar文件名&amp;gt;.tar&#xA;从镜像中按自定义命令启动容器 docker run --restart=always -idt --cpus=&amp;quot;1&amp;quot; -m 1024m -p 7003:7002 --name zhuan_instance zhuan_node /bin/sh -c &amp;quot;cd /var/www &amp;amp;&amp;amp; pm2 start ecosystem.</description>
    </item>
    <item>
      <title>stabilityai/stable-diffusion-3-medium 试用体验</title>
      <link>http://localhost:1313/post/983_stabilityai_stable-diffusion-3-medium-%E8%AF%95%E7%94%A8%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Fri, 21 Jun 2024 23:23:30 +0000</pubDate>
      <guid>http://localhost:1313/post/983_stabilityai_stable-diffusion-3-medium-%E8%AF%95%E7%94%A8%E4%BD%93%E9%AA%8C/</guid>
      <description>在当今的科技领域，人工智能和深度学习技术的发展日新月异。其中，稳定扩散模型（Stable Diffusion Model）作为一种强大的生成模型，在图像生成、视频处理等领域展现出了巨大的潜力。而 ComfyUI 则是一款功能强大的图形用户界面，为用户提供了便捷的操作和可视化的工作流程。 本文将详细介绍如何在 ComfyUI 中安装和使用稳定扩散模型，并通过实际案例展示其在图像生成方面的应用。无论你是初学者还是有一定经验的开发者，都可以通过本文了解到稳定扩散模型的基本原理和使用方法，从而为你的研究和项目提供有力的支持。&#xA;背景知识-名词解释 Stable Diffusion: 是一种强大的人工智能图像生成模型。它的主要功能是根据用户输入的文本描述，生成逼真、富有创意和多样化的图像。用户可以通过输入详细的描述，如主题、场景、颜色、风格、物体的特征等，Stable Diffusion 能够理解这些文本信息，并运用其学习到的知识和算法，生成相应的图像。 ComfyUI: 是一个用于生成图像的用户界面。它通常与图像生成模型（如 Stable Diffusion）结合使用，为用户提供了一种更直观、更易于操作的方式来控制和调整图像生成的参数和设置。ComfyUI 允许用户通过图形化的界面，以拖放、选择、输入数值等方式来定制图像生成的各种条件，例如模型选择、提示词权重、采样方法、步数、分辨率等。 CLIP（Contrastive Language-Image Pre-Training）是一种多模态预训练神经网络，由OpenAI在2021年发布。它的核心思想是使用大量图像和文本的配对数据进行预训练，以学习图像和文本之间的对齐关系。 官方地址 https://huggingface.co/stabilityai/stable-diffusion-3-medium&#xA;安装教程 下载模型，我这里先直接下载16位的试试水 下载comfy UI https://github.com/comfyanonymous/ComfyUI?tab=readme-ov-file#installing&#xA;解压下载好的 comfy UI 7z包 运行run_nvidia_gpu.bat 出现工作流界面则说明安装成功&#xA;导入checkPoint 将下载好的SD模型导入到，ComfyUI的checkpoint文件夹ComfyUI\models\checkpoints&#xA;当在工作流界面可以选择到下载的模型的时候，则说明导入成功&#xA;导入工作流 下载SD3官方的3个流程图文件&#xA;点击load选择要导入的流程图&#xA;流程图文件解释&#xA;sd3_medium_example_workflow_basic.json &amp;ndash; 基础工作流 sd3_medium_example_workflow_multi_prompt.json &amp;ndash; 多prompt工作流 sd3_medium_example_workflow_upscaling.json &amp;ndash; 带图片放大的工作流 配置流程图 切换模型，切换到下载的模型 删除原Clip节点，从模型节点中拖出clip指向prompt。 因为我上面下载的模型自带Clip能力，从模型中引入即可。&#xA;运行SD3模型 输入prompt 运行生图队列 等待一小会，开始运行则说明启动成功&#xA;大功告成 性能占用 我的显卡是4070ti super。运行的模型为16位的，一次运行耗时约10s左右，显存占用90%，基本hold住。</description>
    </item>
    <item>
      <title>在 Windows 下使用 Python virtualenv的教程</title>
      <link>http://localhost:1313/post/982_%E5%9C%A8-windows-%E4%B8%8B%E4%BD%BF%E7%94%A8-python-virtualenv%E7%9A%84%E6%95%99%E7%A8%8B/</link>
      <pubDate>Fri, 07 Jun 2024 22:15:03 +0000</pubDate>
      <guid>http://localhost:1313/post/982_%E5%9C%A8-windows-%E4%B8%8B%E4%BD%BF%E7%94%A8-python-virtualenv%E7%9A%84%E6%95%99%E7%A8%8B/</guid>
      <description>在 Python 开发中，使用虚拟环境是一种常见的最佳实践。它可以帮助我们在同一台计算机上管理多个具有不同依赖关系的项目，避免依赖冲突和版本混乱。本文将介绍如何在 Windows 系统下使用 Python 的 virtualenv 工具创建和管理虚拟环境，并提供一些实用的技巧和建议。&#xA;什么是 virtualenv？ virtualenv 是一个用于创建隔离的 Python 环境的工具。它可以帮助你在同一台计算机上同时运行多个具有不同依赖关系的 Python 项目，而不会相互干扰。&#xA;安装 virtualenv 确保你已经安装了 Python。你可以从 Python 官方网站下载并安装适合你操作系统的版本。 打开命令提示符（CMD）或 PowerShell。 使用以下命令安装 virtualenv：&#xA;pip install virtualenv 创建虚拟环境并指定 Python 版本 在命令提示符或 PowerShell 中，导航到你想要创建虚拟环境的目录。 使用以下命令创建一个新的虚拟环境，并指定所需的 Python 版本：&#xA;virtualenv myenv --python=python3.8 在上述命令中，&amp;ndash;python=python3.8 指定了要使用的 Python 版本为 3.8。你可以根据需要将其替换为任何其他已安装的 Python 版本。&#xA;激活虚拟环境 创建虚拟环境后，你需要激活它才能在其中安装和使用包。 在命令提示符或 PowerShell 中，导航到虚拟环境的目录（在本例中为 myenv）。 输入以下命令激活虚拟环境： 对于 Windows CMD：&#xA;myenv\Scripts\activate.bat 对于 Windows PowerShell：&#xA;myenv\Scripts\Activate.ps1 激活虚拟环境后，你的命令提示符或 PowerShell 前缀将显示虚拟环境的名称，表明你现在正在虚拟环境中工作。&#xA;安装包 在激活的虚拟环境中，你可以使用 pip 安装所需的包。 例如，要安装 numpy 包，可以使用以下命令：</description>
    </item>
    <item>
      <title>Python venv：创建虚拟环境及生成 requirements.txt</title>
      <link>http://localhost:1313/post/981_python-venv_%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%8F%8A%E7%94%9F%E6%88%90-requirements_txt/</link>
      <pubDate>Sun, 19 May 2024 18:29:53 +0000</pubDate>
      <guid>http://localhost:1313/post/981_python-venv_%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%8F%8A%E7%94%9F%E6%88%90-requirements_txt/</guid>
      <description>引言 在 Python 开发中，管理项目的依赖是一项重要的任务。为了避免不同项目之间的依赖冲突，我们通常会使用虚拟环境来隔离每个项目的依赖。Python 的 venv 模块就是一个用于创建虚拟环境的工具。在本文中，我们将介绍如何在 Windows 环境下使用 venv 模块创建虚拟环境，并生成 requirements.txt 文件来管理项目的依赖。&#xA;一、什么是 Python venv？ Python venv 是 Python 标准库中的一个模块，用于创建虚拟环境。虚拟环境是一个独立的 Python 运行环境，它包含了项目所需的 Python 解释器和所有依赖包。通过使用虚拟环境，我们可以在不同的项目中使用不同的依赖版本，从而避免依赖冲突。&#xA;二、如何创建 Python venv？ 在 Windows 环境下，我们可以使用以下命令创建 Python venv：&#xA;打开命令提示符（CMD）或 PowerShell。 进入项目目录。 运行以下命令创建虚拟环境： python -m venv venv 其中，venv 是虚拟环境的名称，你可以根据需要修改。&#xA;4. 激活虚拟环境： 在 CMD 中，运行以下命令激活虚拟环境：&#xA;venv\Scripts\activate 在 PowerShell 中，运行以下命令激活虚拟环境：&#xA;venv\Scripts\Activate.ps1 激活虚拟环境后，命令提示符或 PowerShell 前面会出现 (venv) 前缀，表示当前处于虚拟环境中。&#xA;三、如何安装依赖？ 在虚拟环境中，我们可以使用 pip 命令安装项目所需的依赖。例如，如果我们的项目需要安装 numpy 和 pandas 两个包，可以运行以下命令：&#xA;pip install numpy pandas 四、如何生成 requirements.</description>
    </item>
    <item>
      <title>在 Windows 系统中配置 pip 清华源</title>
      <link>http://localhost:1313/post/980_%E5%9C%A8-windows-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%85%8D%E7%BD%AE-pip-%E6%B8%85%E5%8D%8E%E6%BA%90/</link>
      <pubDate>Wed, 15 May 2024 23:46:18 +0000</pubDate>
      <guid>http://localhost:1313/post/980_%E5%9C%A8-windows-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E9%85%8D%E7%BD%AE-pip-%E6%B8%85%E5%8D%8E%E6%BA%90/</guid>
      <description>在使用 Python 进行开发时，我们经常会用到 pip 来安装各种包。但有时默认的源下载速度可能较慢，这时候配置国内的镜像源就很有必要了。这里介绍如何在 Windows 系统中配置 pip 的清华源。&#xA;第一步：创建配置文件 在你的用户目录下（一般是 C:\Users\你的用户名），可以通过在资源管理器的地址栏输入 %appdata% 后回车快速打开 appdata 文件夹。创建一个名为 pip 的文件夹，然后在该文件夹内创建一个名为 pip.ini 的文件。&#xA;第二步：编辑配置文件 用文本编辑器打开 pip.ini 文件，在其中添加以下内容：&#xA;[global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple 第三步：验证配置 打开命令提示符，输入 pip install 某个包，观察下载速度是否有所提升。如果配置成功，下载速度应该会比之前快很多。</description>
    </item>
    <item>
      <title>游戏设计模式之组件模式</title>
      <link>http://localhost:1313/post/978_%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 04 Jun 2023 16:20:04 +0000</pubDate>
      <guid>http://localhost:1313/post/978_%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%BC%8F/</guid>
      <description>&#xA;前言 我第一次接触到组件模式是在饥荒的mod开发过程中了解到的。在组件模式下，一系列的能力（如灯光，buff）将会被抽象为组件，组件内部实现这种能力。不同的对象都可以使用这一个组件，提高代码的复用性，避免耦合性过强。&#xA;什么是组件模式 允许一个单一的实体跨越多个不同域而不会导致耦合。&#xA;为什么需要组件模式 组件模式的目的是减少代码耦合性，提高代码复用率。&#xA;可以拿饭店菜单打比方。如果每个实体是一个类，那就只能订套餐。 我们需要为每种可能的组合定义各自的类。 为了满足每位用户，我们需要十几种套餐。&#xA;组件是照单点菜——每位顾客都可以选他们想要的，菜单记录可选的菜式。&#xA;参考文档 组件模式 【游戏编程模式】组件模式 </description>
    </item>
    <item>
      <title>Vue3使用customRef()主动触发响应更新</title>
      <link>http://localhost:1313/post/975_vue3%E4%BD%BF%E7%94%A8customref__%E4%B8%BB%E5%8A%A8%E8%A7%A6%E5%8F%91%E5%93%8D%E5%BA%94%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Mon, 12 Dec 2022 22:11:09 +0000</pubDate>
      <guid>http://localhost:1313/post/975_vue3%E4%BD%BF%E7%94%A8customref__%E4%B8%BB%E5%8A%A8%E8%A7%A6%E5%8F%91%E5%93%8D%E5%BA%94%E6%9B%B4%E6%96%B0/</guid>
      <description>前言 在vue3中（尤其是setup语法）vue框架会自动处理事件响应。但是假设有个场景，我们实现了一个数据结构，只要触发对应操作时，就刷新视图。这个问题在选项式API有个公共API，提供强制刷新能力，那就是$forceUpdate()。$forceUpdate()会全量刷新，而且组合式API不支持该方法，这个时候如果我们想主动触发视图更新，可以使用Vue3提供的customRef()自定义一个ref。&#xA;介绍 customRef()，创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。&#xA;形如&#xA;function customRef&amp;lt;T&amp;gt;(factory: CustomRefFactory&amp;lt;T&amp;gt;): Ref&amp;lt;T&amp;gt; type CustomRefFactory&amp;lt;T&amp;gt; = ( track: () =&amp;gt; void, trigger: () =&amp;gt; void ) =&amp;gt; { get: () =&amp;gt; T set: (value: T) =&amp;gt; void } 其中，track函数告诉框架这是一个需要追踪变更的变量，一般在get里面调用。trigger则是数据变化时调用，用以通知框架，该变量已发生变化触发视图更新。&#xA;示例 实现一个日志展示功能，当日志增加时，触发视图更新&#xA;这是一个简陋的日志系统，永远展示最后十条日志(截图少了个.slice(-10))。而且我在程序最后加了个定时器，每隔一秒定时增加一条日志。&#xA;从图中的结果可以发现，对应的数据变化并未相应的渲染在视图上。这个使用我们就需要customRef实现一个自定义的ref，当日志增加时主动触发trigger通知视图更新&#xA;使用customRef改造 总结 使用customRef的好处就是可以把trigger暴露到外部，直接触发trigger就会触发刷新，实现按需加载的效果。</description>
    </item>
    <item>
      <title>如何理解Promise</title>
      <link>http://localhost:1313/post/956_%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3promise/</link>
      <pubDate>Fri, 09 Dec 2022 21:35:49 +0000</pubDate>
      <guid>http://localhost:1313/post/956_%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3promise/</guid>
      <description>Promise是啥？异步函数？对象？怎么用才更自信？如何理解更好的理解Promise？本文将分享本人对于Promise的一些经验与想法。&#xA;背景知识 此段将介绍一些理解本文的背景知识，你可以很轻松愉快的阅读此段。&#xA;函数是一等公民 总所周知，在JavaScript里面，函数是一等公民。你可以用来赋值，传参，回调，包装，作为函数返回值return。&#xA;以下内容援引于JavaScript 为什么说函数是一等公民？&#xA;函数与数字一样可以存储到变量中 var fortyTwo = 42 var fortyOne = function() { return 41; } 函数与数字一样可以存储为数组的一个元素 var nums = [42, function() { return 41 }] 函数与数字一样可以在使用时直接创建出来 42 + (fuction() { return 41 })(); // 83 函数与数字一样可以被传递给另一个函数 function weirdAdd( n, fun) { return n + fun()} weirdAdd(42, function() { return 41 }) 函数与数字一样可以被另一个函数返回 function add() { var num1 = 42; return function(num2) { return num1 + num2 } } fun = add(); fun(41); // 83 函数就是变量，变量可以存放函数。就是玩~</description>
    </item>
    <item>
      <title>前端模块化</title>
      <link>http://localhost:1313/post/943_%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Wed, 15 Jun 2022 00:00:02 +0000</pubDate>
      <guid>http://localhost:1313/post/943_%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>什么是模块化？ 在程序设计领域，模块就是为完成某一个功能的一段程序或者子程序&#xA;一个文件可以是一个模块，一个文件夹也可以是一个模块。模块的思想完美的符合了设计模式中的单一职责原则。只做一件事，或者一类事，分清任务的边界。&#xA;为什么需要模块化？ 模块化的目的是将任务细分，在现阶段的软件工程阶段，模块化的方式可以将一个大任务分给不同的人或组织，每个人所负责的模块相对独立而又互为依存关系。而在开源领域和工程复用阶段，模块化可以让我们更方便的站在人民群众的肩膀上，众人拾薪柴火高。使我们可以更多的关注业务逻辑，而不用过分在意实现细节。&#xA;现阶段前端有哪些模块化方式？ 现阶段前端模块化规范有这几种，AMD（Asynchronous Module Definition，CMD（Common Module Definition），CommonJs，Es6 Moduel；&#xA;AMD(require.js) AMD规范如其全名一致，异步模块定义。是require.js 在推广过程中对模块化定义的规范产出的。它的主要思想是前置依赖，让依赖先加载和执行，然后再之后后面的语句。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，才会运行这个回调函数。&#xA;CMD(sea.js) CMD与AMD规范不一样，AMD是一种与预加载的方式，否管你有没有用到，先把依赖加载进来执行了再说。而CMD是按需依赖的形式，你先运行把，运行到哪里了缺啥你再告诉我，我给你按需依赖。&#xA;Commonjs CommonJs，运行时加载，理论上来说，这个规范一般都是用于服务端的node环境，与前端可能相关性不大，但是作为Js的模块化规范的几大巨头之一，我们也应该了解其思想和实现逻辑。CommonJs模块都是对象，先读取加载整个模块，生成一个对象，然后再从这个对象上面读取方法。由于它是读取后深拷贝（对值的拷贝）这个时候你再进行模块内部变量的改变，是不会影响原依赖模块的使用。CommonJs是同步加载的，一般同步就意味着等待，而有效等待的前提就需要良好的运行环境，这在浏览器上变换莫测的网络环境显然是没法满足的，一个404的js，就造成页面的长时间等待。所以这个规范一般被用作服务端node环境。&#xA;ES6 module 在我学前端的心路历程中，但凡跟ES6扯上关系的，总得带点牛逼气息，ES6 module也是如此，它是从语言层面定义的模块化解决方案。ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。&#xA;我该用哪种模块化方式？ 答：当然是最牛逼的&#xA;理想上，我们应该全部使用ES6 module这种牛逼的方式。但是理想与现实总是存在着略微的差距，虽然我们平常写Vue组件，ES6 module 用得是肆无忌惮，风生水起。但这并不意味着我们现在生产环境上用的就是这个模式，所见有时并非所得。一方面并非所有的浏览器都能够支持ES6 module，另一方面则是由于，现如今磅礴的前端生态环境，巨额的嵌套引用入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。实际上当我们run build时，聪明的打包器帮我们完成一系列操作，tree-shaking、懒加载和 chunk 分割（以获得更好的缓存），让我们以最淳朴的形式表现于浏览器，当真是反哺归真。&#xA;参考文档 为什么选 Vite&#xA;前端模块化&#xA;模块设计术语</description>
    </item>
    <item>
      <title>vue3.x简单实现wx.showModal()</title>
      <link>http://localhost:1313/post/936_vue3_x%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0wx_showmodal__/</link>
      <pubDate>Mon, 30 Nov 2020 23:30:53 +0000</pubDate>
      <guid>http://localhost:1313/post/936_vue3_x%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0wx_showmodal__/</guid>
      <description>引言 开发过微信小程序的同学想必都对wx.showModal不陌生。用起来还是比较方便的，以api的形式挂载在全局对象wx上，只需调用一下这个api即可显示一个弹窗，还可以根据设置的参数做一些定制。一些知名的组件库，也实现了此类功能。比如element的$message。所以，我也来分享一个简单实现方式，以此来加深对Vue的理解。&#xA;代码结构 在Message目录下，有着两个文件，vue文件负责组件内容，js负责处理服务APi。&#xA;实现原理 首先使用vue文件创建一个弹窗组件，然后按正常写组件方式写一个组件逻辑。唯一不同的是引入方式不一样，不在别的组件中引用该组件。使用js文件将其注册到全局api，调用该api。&#xA;实现过程 注意：本文使用的是Vue3.x版本。由于本人Vue3.x也正出于学习之处，如有理解/实现不当之处，恳请指正！&#xA;Vue文件 &amp;lt;template&amp;gt; &amp;lt;div v-if=&amp;#34;visible&amp;#34; class=&amp;#34;tm-message-wrapper&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;tm-message-dialog&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;tm-message-title&amp;#34;&amp;gt;{{ title }}&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;tm-message-content&amp;#34;&amp;gt;{{ content }}&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;tm-message-noRepeat&amp;#34; v-if=&amp;#34;showNoRepeat&amp;#34;&amp;gt;&amp;lt;input type=&amp;#34;checkbox&amp;#34; v-model=&amp;#34;noRepeat&amp;#34;&amp;gt;不再提示&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;tm-message-operation-area&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;tm-message-cancel tm-message-operation&amp;#34; @click=&amp;#34;action(&amp;#39;cancel&amp;#39;)&amp;#34;&amp;gt;取消&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;tm-message-confirm tm-message-operation&amp;#34; @click=&amp;#34;action(&amp;#39;confirm&amp;#39;)&amp;#34;&amp;gt;确定&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { data() { return { uid: &amp;#34;default&amp;#34;, visible: false, title: &amp;#34;提示&amp;#34;, content: &amp;#34;消息内容&amp;#34;, showNoRepeat: false, noRepeat: false, callBack: null } }, methods: { action(action) { this.</description>
    </item>
    <item>
      <title>box-sizing是什么？</title>
      <link>http://localhost:1313/post/919_box-sizing%E6%98%AF%E4%BB%80%E4%B9%88_/</link>
      <pubDate>Sun, 20 Sep 2020 22:42:43 +0000</pubDate>
      <guid>http://localhost:1313/post/919_box-sizing%E6%98%AF%E4%BB%80%E4%B9%88_/</guid>
      <description>笔者初学前端时，遇到一些具有padding/border的子元素铺满父元素时，常常采用人工计算width的方式来实现效果。知道后来了解到box-sizing，才知道那种实现方式是多么的尴尬！&#xA;box-sizing box-sizing 属性允许你以某种方式定义某些元素，以适应指定区域。&#xA;box-sizing具有三个值&#xA;content-box，默认值，指定盒模型为 W3C 标准模型，设置 border、padding 会增加元素 width与 height 的尺寸。&#xA;border-box，指定盒模型为 IE模型（怪异模式），设置 border、padding 不会影响元素 width 与 height 的尺寸。&#xA;inherit，继承&#xA;举个例子 &amp;lt;template&amp;gt; &amp;lt;block&amp;gt; &amp;lt;div class=&amp;#34;parent&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;child&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/block&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; export default { name: &amp;#34;HelloWorld&amp;#34;, props: { msg: String } }; &amp;lt;/script&amp;gt; &amp;lt;!-- Add &amp;#34;scoped&amp;#34; attribute to limit CSS to this component only --&amp;gt; &amp;lt;style scoped&amp;gt; div{ display: inline-block; height: 100px; width: 100px; padding: 10px; border-width: 10px; margin: 10px; } .</description>
    </item>
    <item>
      <title>Vue自定义指令</title>
      <link>http://localhost:1313/post/910_vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Sun, 20 Sep 2020 13:30:27 +0000</pubDate>
      <guid>http://localhost:1313/post/910_vue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</guid>
      <description>介绍 Vue中的指令形如v-*，如v-if，v-show，v-model等。同时，除了Vue自带的一些默认指令外，Vue同时运行用户自定义指令，来扩展指令功能。&#xA;使用场景 究竟什么情况下使用组件？而什么情况下使用指令呢？官方对此，给出了以下建议：&#xA;注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。&#xA;也就是说，当你关注问题的抽象层级在DOM元素的时候，你就应该考虑使用自定义指令来完成需求了。&#xA;作用范围 自定义指令有两种作用范围，一种是申明在全局，全局内有效。另一种，则是局部指令。&#xA;钩子函数及相关参数见官网文档。&#xA;举个例子 需求 我需要设计一个自定义指令v-bug，该指令可将作用元素的所有内容都替换为烫烫烫烫，指令可以指定有几个烫，以及是否追加锟斤拷。&#xA;1. 先将内容替换为一个烫 main.js&#xA;import Vue from &amp;#39;vue&amp;#39; import App from &amp;#39;./App.vue&amp;#39; Vue.config.productionTip = false Vue.directive(&amp;#39;bug&amp;#39;, { inserted: function (el) { el.innerHTML = &amp;#34;烫&amp;#34; } }) new Vue({ render: h =&amp;gt; h(App), }).$mount(&amp;#39;#app&amp;#39;) App.vue&#xA;&amp;lt;template&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;HelloWorld v-bug /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; import HelloWorld from &amp;#39;./components/HelloWorld.vue&amp;#39; export default { name: &amp;#39;App&amp;#39;, components: { HelloWorld } } &amp;lt;/script&amp;gt; &amp;lt;style&amp;gt; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } &amp;lt;/style&amp;gt; 效果展示</description>
    </item>
    <item>
      <title>浏览器机制之js事件循环</title>
      <link>http://localhost:1313/post/907_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6%E4%B9%8Bjs%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Fri, 28 Aug 2020 20:32:26 +0000</pubDate>
      <guid>http://localhost:1313/post/907_%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%BA%E5%88%B6%E4%B9%8Bjs%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</guid>
      <description>引言 总所周知，js是单线程的。单线程意味着，js代码在执行的任何时候，都只有一个主线程来处理所有的任务（为了避免多线程可能产生的诸多问题，直接阉割多线程的可能性）。然而，随着硬件设备的快速发展，网页要做的事情会变得越来越多。人们慢慢意识到，不能让单线程限制了js的效率，然后web worker便应运而生。&#xA;栈，堆，队列 基本数据结构知识略过~&#xA;讲讲它们在js语言层面的应用。&#xA;执行栈：函数调用形成了一个由若干帧（执行上下文）组成的栈。&#xA;消息队列：一个待处理消息的消息队列。每一个消息都关联着一个用以处理这个消息的回调函数。&#xA;在 事件循环 期间的某个时刻，运行时会从最先进入队列的消息开始处理队列中的消息。被处理的消息会被移出队列，并作为输入参数来调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。&#xA;函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。&#xA;任务队列 在js事件循环机制中，存在多种任务队列，它们可分为宏任务（macro-task）和微任务（micro-task）两种。&#xA;宏任务包括：setTimeout、setInterval、I/O、UI rendering&#xA;微任务包括：process.nextTick、Promise、Object.observe（已废弃）、MutationObserver（html5新特性）&#xA;事件循环 如上图所示，事件循环就是在主线程清空执行上下文栈后空闲之时，先去微任务队列中读取待执行程序，并装载到主线程中。如果没有内容（各类微任务队列都清空），则将去宏任务队列中寻找。如此往复，周而复始，直至结束。&#xA;参考文档 并发模型与事件循环-MDN&#xA;详解JavaScript中的Event Loop（事件循环）机制-知乎&#xA;JS事件循环机制（event loop）之宏任务/微任务-掘金&#xA;JavaScript 事件循环机制-掘金</description>
    </item>
    <item>
      <title>Vue环境变量和模式</title>
      <link>http://localhost:1313/post/894_vue%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 12 Aug 2020 15:54:15 +0000</pubDate>
      <guid>http://localhost:1313/post/894_vue%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E6%A8%A1%E5%BC%8F/</guid>
      <description>Vue环境变量和模式 我最开始使用vue的判断环境的方法是&#xA;let BASE_URL = process.env.NODE_ENV == &amp;#34;development&amp;#34; ? &amp;#34;http:/localhost&amp;#34; : &amp;#34;xxx&amp;#34; 在这种情况下，需要先判断它的编译环境，进而根据环境适用对应的值。如果只有一个地方的变量跟环境有关，情况还好。但是若有多个，则需要复制多个判断或者封装成一个方法。但也只能使用于两个环境，如果存在多个环境，诸如开发，测试，预发布，正式等环境，这个方法就捉襟见肘了。所以，我们需要设置Vue环境变量和模式，好像webpack也可以实现？（好吧，这不是重点）&#xA;实现方式 vue允许你在项目根目录下添加.env.[mode]的文件来指定环境变量。&#xA;.env # 在所有的环境中被载入 .env.local # 在所有的环境中被载入，但会被 git 忽略 .env.[mode] # 只在指定的模式中被载入 .env.[mode].local # 只在指定的模式中被载入，但会被 git 忽略 比如我，我添加了.env.local,.env.development,.env.test,.env.production等文件，.env.local文件内容如下。&#xA;.env.local&#xA;VUE_APP_BUILD_MODE = &amp;#39;development&amp;#39; VUE_APP_BASE_URL = &amp;#39;http://172.16.6.132:8002/threemiju/&amp;#39; 对应package.json的script如下:&#xA;&amp;#34;scripts&amp;#34;: { &amp;#34;serve&amp;#34;: &amp;#34;vue-cli-service serve --mode&amp;#34;, &amp;#34;serve:test&amp;#34;: &amp;#34;vue-cli-service serve --mode test&amp;#34;, &amp;#34;build:test&amp;#34;: &amp;#34;vue-cli-service build --mode test&amp;#34;, &amp;#34;build:production&amp;#34;: &amp;#34;vue-cli-service build --mode production&amp;#34;, &amp;#34;deploy:test&amp;#34;: &amp;#34;git push &amp;amp;&amp;amp; git push gitlab dev &amp;amp;&amp;amp; vue-cli-service build --mode test&amp;#34; }, 请注意，此处有一个坑。当你使用yarn run build:test的时候，你会发现，假如你使用了异步组件，却会神奇的发现，它并没有把把代码切割，只编译成了一个app.</description>
    </item>
    <item>
      <title>微信小程序自定义tabBar在uni-app的适配</title>
      <link>http://localhost:1313/post/375_%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89tabbar%E5%9C%A8uni-app%E7%9A%84%E9%80%82%E9%85%8D/</link>
      <pubDate>Fri, 10 Jul 2020 09:12:17 +0000</pubDate>
      <guid>http://localhost:1313/post/375_%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89tabbar%E5%9C%A8uni-app%E7%9A%84%E9%80%82%E9%85%8D/</guid>
      <description>引言：此方法可用作大部分微信小程序支持，但uni-app文档中却找不到相关说明的API&#xA;需求 需要在微信小程序中，实现一个中间图标突出显示的异形导航栏。&#xA;如下图 实现方法设计 要做这种异形的导航栏，用直接在配置文件里面写list的方法肯定做不到。那么，就有以下两种可替代方法。&#xA;在每一个页面都加载一个tabBar组件，与页面同时渲染。&#xA;设置自定义tabBar,修改tabBar的样式。&#xA;优缺点分析：方法1实现起来略为简单，但是会出现代码可重用率低，降低性能，已经界面跳动等问题。方法2则是微信官方提供的，自定义方式，相信在性能方面也会有很大的优势。故选择方法2。&#xA;1. 查看文档及官方Demo 官方文档&#xA;简要描述一下就是需要在根目录中加入一个custom-tab-bar目录，里面的文件结构与自定义组件的结构一致。然后再在小程序配置文件中修改tabbar为custom模式。&#xA;官方代码&#xA;主要重点为三个部分&#xA;配置文件 custom-tab-bar目录 页面生命周期中的设置索引方法 这段代码其实很容易理解，pageLifetimes就是监听组件所在页面的生命周期。上述代码就是监听页面显示。当页面显示后，获取到tabBar的对象，然后再设置tabBar中的index索引。&#xA;2. 迁移到uni-app框架 上面的方法是使用微信小程序的开发方式，而我使用的是uni-app框架开发微信小程序的。所以我们需要把它们移植到uni-app框架内。&#xA;配置文件的修改 uni-app中，page.json被编译为微信小程序的app.json。所以，我们直接修改page.json&#xA;custom-tab-bar目录的适配 我们知道，uni-app使用的是类Vue开发，将一个Vue文件编译为四个微信页面文件（wxml，wxss，json，js）。那么，是否可以直接写一个custom-tab-bar.vue的文件呢？刚开始我也是这么想的，后来发现uni-app只会编译page目录和component目录下的vue文件。而微信小程序要求custom-tab-bar必须在项目的根目录下。那么就只能在uni-app下创建一个custom-tab-bar目录，并老老实实写微信四件套了。&#xA;写完后，uni-app会将该目录完美的复制至微信小程序项目的根目录。&#xA;tab页面内的适配方法 这个在我实际开发中，是最令我头痛的了。因为微信小程序的this引用与uni-app的this引用并不相同。所以如果直接复制代码是会编译出错的。而另一个问题则是，uni-app并未提供pageLifetimes的事件监听。&#xA;在我经过一番摸索之后，发现将设置索引方法写在onShow事件里面，效果是等效的。接下来便只剩下this的问题了。&#xA;如果直接复制的话，会出现无任何效果的情况&#xA;因为uni-app的this引用不一样，所以它在判断getTabBar的时候，获取的是“undefined”所以不会执行下面的操作。如果你将判断去掉，则会直接报“undefined”错误。&#xA;难道实现不了？其实不然，万变不离其宗。uni-app也是编译到小程序的，所以绝对有迹可循。&#xA;我们首先看看uni-app里面this的内容。&#xA;我们可以很明显的看到里面有个$mp的对象，说明这应该是微信小程序专用的对象。接下来我们继续分析$mp。&#xA;这里面有一个隐藏很深的getTabBar方法，我们直接调用它，和在微信小程序里面调用this.getTabBar是等效的。&#xA;所以我们就可以把onShow里面的内容写成这样。&#xA;一些优雅点的封装 设置索引方法独立出来 在methods对象中，添加&#xA;setTabBarIndex(index){ if (typeof this.$mp.page.getTabBar === &amp;#39;function&amp;#39; &amp;amp;&amp;amp; this.$mp.page.getTabBar()) { this.$mp.page.getTabBar().setData({ selected:index }) } } 使用mixin避免重复书写复制 在main.js中，添加&#xA;Vue.mixin({ methods:{ setTabBarIndex(index){ if (typeof this.$mp.page.getTabBar === &amp;#39;function&amp;#39; &amp;amp;&amp;amp; this.$mp.page.getTabBar()) { this.$mp.page.getTabBar().setData({ selected:index }) } } } }) 混入后的使用 在页面文件中</description>
    </item>
    <item>
      <title>Django启航篇</title>
      <link>http://localhost:1313/post/269_django%E5%90%AF%E8%88%AA%E7%AF%87/</link>
      <pubDate>Tue, 30 Jun 2020 22:23:05 +0000</pubDate>
      <guid>http://localhost:1313/post/269_django%E5%90%AF%E8%88%AA%E7%AF%87/</guid>
      <description>安装pip3 sudo apt-get install python3-pip 安装Django sudo pip3 install django 验证安装 创建项目 django-admin startproject convert 运行 python3 manage.py runserver </description>
    </item>
    <item>
      <title>vue中使用typescript问题解决方案集锦</title>
      <link>http://localhost:1313/post/876_vue%E4%B8%AD%E4%BD%BF%E7%94%A8typescript%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%9B%86%E9%94%A6/</link>
      <pubDate>Tue, 23 Jun 2020 22:04:32 +0000</pubDate>
      <guid>http://localhost:1313/post/876_vue%E4%B8%AD%E4%BD%BF%E7%94%A8typescript%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%9B%86%E9%94%A6/</guid>
      <description>本文环境 @vue/cli 4.3.1&#xA;typescript 3.9.5&#xA;相关配置文件 vue.config.js&#xA;tsconfig.json&#xA;shims-vue.d.ts&#xA;问题汇总 导入 vue 文件报错 错误信息：Cannot find module &amp;lsquo;./App.vue&amp;rsquo; or its corresponding type declarations&#xA;解决方案：修改shims-vue.d.ts&#xA;declare module &amp;#34;*.vue&amp;#34; { import Vue from &amp;#34;vue&amp;#34;; export default Vue; } Vscode 报错，编译不报错 解决方案：重启 Vscode&#xA;挂载原型$api 报错 解决方案：在src目录下新增vue-property.d.ts&#xA;import Vue from &amp;#39;vue&amp;#39; declare module &amp;#34;vue/types/vue&amp;#34; { interface Vue { $api: any; } } 无法使用@components别名 alias 路径 解决方案: 修改tsconfig.json&#xA;{ &amp;#34;compilerOptions&amp;#34;: { &amp;#34;target&amp;#34;: &amp;#34;esnext&amp;#34;, &amp;#34;module&amp;#34;: &amp;#34;esnext&amp;#34;, &amp;#34;strict&amp;#34;: true, &amp;#34;jsx&amp;#34;: &amp;#34;preserve&amp;#34;, &amp;#34;importHelpers&amp;#34;: true, &amp;#34;moduleResolution&amp;#34;: &amp;#34;node&amp;#34;, &amp;#34;experimentalDecorators&amp;#34;: true, &amp;#34;esModuleInterop&amp;#34;: true, &amp;#34;allowSyntheticDefaultImports&amp;#34;: true, &amp;#34;sourceMap&amp;#34;: true, &amp;#34;baseUrl&amp;#34;: &amp;#34;.</description>
    </item>
    <item>
      <title>初探vue3.0笔记</title>
      <link>http://localhost:1313/post/881_%E5%88%9D%E6%8E%A2vue3_0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 23 Jun 2020 22:03:02 +0000</pubDate>
      <guid>http://localhost:1313/post/881_%E5%88%9D%E6%8E%A2vue3_0%E7%AC%94%E8%AE%B0/</guid>
      <description>&#xA;tips: 请注意区分vue3.0和vue cli 3.x/4.x&#xA;创建项目 vue create -r https://registry.npm.taobao.org vue-next-test 选择你喜欢的配置即可，创建成功后，从Demo来看，跟vue2.0的typescript写法差别看起来不大的样子。。。&#xA;未完待续 </description>
    </item>
    <item>
      <title>gitlab中vue前端项目CI/CD部署笔记</title>
      <link>http://localhost:1313/post/849_gitlab%E4%B8%ADvue%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AEci_cd%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 23 Jun 2020 19:34:48 +0000</pubDate>
      <guid>http://localhost:1313/post/849_gitlab%E4%B8%ADvue%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AEci_cd%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</guid>
      <description>持续集成 略&#xA;Gitlab的持续集成 我们可以将整个运行机制，看作一个赏金猎人接任务，执行任务，并完成任务的过程。&#xA;GitLab-CI 简单来说，这就是一个任务发布平台。运行在gitlab服务器，监听代码状态变化，并发布对应的任务。&#xA;GitLab-Runner 而每个runner就是一位赏金猎人，是任务的执行者。&#xA;.gitlab-ci.yml 任务的发布者，规定什么时候触发任务，任务的具体内容。&#xA;配置流程 经过前面的解释，整个思路就很清晰了。我们需要做的有三件事。&#xA;编写.gitlab-ci.yml文件，设置对应的任务&#xA;部署Runner，激活赏金猎人&#xA;配置ci，邀请赏金猎人加入系统&#xA;部署Runner 这一步需要一个服务器，能run起来赏金猎人。&#xA;安装 请务必安装最新版，不然会出现很多未知的问题&#xA;下载二进制文件 # Linux x86-64 sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64 # Linux x86 sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-386 # Linux arm sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-arm # Linux arm64 sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-arm64 授予执行权限 sudo chmod +x /usr/local/bin/gitlab-runner Create a GitLab CI user: sudo useradd --comment &amp;#39;GitLab Runner&amp;#39; --create-home gitlab-runner --shell /bin/bash Install and run as service: sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner sudo gitlab-runner start 加入任务系统 注册</description>
    </item>
    <item>
      <title> Vue按需引入element ui笔记</title>
      <link>http://localhost:1313/post/843_vue%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5element-ui%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 23 Jun 2020 09:00:34 +0000</pubDate>
      <guid>http://localhost:1313/post/843_vue%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5element-ui%E7%AC%94%E8%AE%B0/</guid>
      <description>按官网文档一键配置按需引入总是无法生效，目测可能是激进式预设没有选babel的原因。故写此文详细记录折腾过程，望有效！&#xA;vue ui创建新项目 选择预设，bable，eslint，vuex，vue-router(历史模式)&#xA;vue ui安装element插件 选择配置&#xA;改动的内容 自动创建了bable.config.js,并添加了内容。&#xA;创建了`@/src/plugins/element.js,设置了按需引入&#xA;改写了app.vue,添加了element按钮组件&#xA;运行测试 加载成功&#xA;Q&amp;amp;A 为什么需要bable来支持按需加载 如果不使用bable转码，那你按需引入会找不到该组件。这是由于bable在将组件库转码的过程中把element整个组件库编译成了各种独立的组件模块，进而实现按需加载的功能&#xA;如何添加需要的组件 使用vue ui添加后的组件会在plugins目录下创建element.js文件，然后在main.js中引入该文件。文件内容如下：&#xA;import Vue from &amp;#34;vue&amp;#34;; import { Button } from &amp;#34;element-ui&amp;#34;; Vue.use(Button); 这就是只引入Button的方法，如果要按需添加，只需要依葫芦画瓢即可！</description>
    </item>
    <item>
      <title>Vue cli 笔记</title>
      <link>http://localhost:1313/post/834_vue-cli-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 23 Jun 2020 08:59:51 +0000</pubDate>
      <guid>http://localhost:1313/post/834_vue-cli-%E7%AC%94%E8%AE%B0/</guid>
      <description>安装 全局安装@vue/cli&#xA;yarn global add @vue/cli 检查是否安装成功(需重启更新环境变量)&#xA;vue --version 快速原型开发 新版本Vue中增加了该功能，方便快速进行单个Vue文件开发，需要先额外安装一个全局的扩展。&#xA;yarn global add @vue/cli-service-global 入手尝鲜&#xA;新建index.vue文件 &amp;lt;template&amp;gt; &amp;lt;div&amp;gt;Hello Vue&amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; 运行服务 vue serve index.vue 效果 创建项目 略&#xA;vue.config.js 在vue cli 3.x/4.x 中，使用vue.cofig.js来进行一些包括webpack的配置。比如我们可以想要一个控制台输出编译时间的配置，可以在如下设置&#xA;const moment = require(&amp;#39;moment&amp;#39;) module.exports = { chainWebpack: config =&amp;gt; { config .plugin(&amp;#39;html&amp;#39;) .tap(args =&amp;gt; { args[0].title = &amp;#39;三只蜜桔后台管理系统·商户版&amp;#39;, args[0].buildTime = moment().format(&amp;#39;YYYY.MM.DD.HH.mm&amp;#39;) return args }) } } 亦或者，我们想要在生产环境禁用console.log&#xA;const moment = require(&amp;#39;moment&amp;#39;) module.exports = { chainWebpack: config =&amp;gt; { config .</description>
    </item>
    <item>
      <title>el-upload视频上传支持回显和预览的一种异教徒解决方案</title>
      <link>http://localhost:1313/post/861_el-upload%E8%A7%86%E9%A2%91%E4%B8%8A%E4%BC%A0%E6%94%AF%E6%8C%81%E5%9B%9E%E6%98%BE%E5%92%8C%E9%A2%84%E8%A7%88%E7%9A%84%E4%B8%80%E7%A7%8D%E5%BC%82%E6%95%99%E5%BE%92%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</link>
      <pubDate>Thu, 18 Jun 2020 11:28:57 +0000</pubDate>
      <guid>http://localhost:1313/post/861_el-upload%E8%A7%86%E9%A2%91%E4%B8%8A%E4%BC%A0%E6%94%AF%E6%8C%81%E5%9B%9E%E6%98%BE%E5%92%8C%E9%A2%84%E8%A7%88%E7%9A%84%E4%B8%80%E7%A7%8D%E5%BC%82%E6%95%99%E5%BE%92%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</guid>
      <description>该文章为异教徒解决方案，各位看官看下即可，切勿模仿！！！&#xA;问题描述 原生的el-upload只支持上传图片时候的预览和回显，这是因为只针对img标签做了适配，如下图。&#xA;而如果我们上传视频，则会出现一个白方框，用户体验不佳。&#xA;解决思路 其实正确的解决思路应该是&#xA;将show-file-list属性设置为false。然后再自己循环显示file-list，以及追加对应的预览，删除按钮及功能。&#xA;设置自定义模板内容(推荐使用)&#xA;但是我觉得这样太麻烦了(时间问题）。&#xA;于是我突发奇想，如果我将img标签改成video标签呢？如下图&#xA;发现居然完美契合，毫无违和感。&#xA;预览的实现 在做到把img改为video标签之前，还需要解决的另一个问题就是，如何让视频也支持预览。老规矩，我们先来看看官方Demo怎么实现预览的。&#xA;官方的做法是增加一个dialog，然后在点击预览图片时将文件url传给dialog。我们先来实现一下改写一下dialog&#xA;&amp;lt;el-dialog :visible.sync=&amp;#34;dialogVisible&amp;#34; :modal-append-to-body=&amp;#34;true&amp;#34;&amp;gt; &amp;lt;video width=&amp;#34;100%&amp;#34; muted autoplay=&amp;#34;autoplay&amp;#34; loop=&amp;#34;loop&amp;#34; v-if=&amp;#34;dialogImageUrl[dialogImageUrl.length - 1] == 4&amp;#34; :src=&amp;#34;dialogImageUrl&amp;#34;&amp;gt;&amp;lt;/video&amp;gt; &amp;lt;img width=&amp;#34;100%&amp;#34; v-else :src=&amp;#34;dialogImageUrl&amp;#34; alt /&amp;gt; &amp;lt;/el-dialog&amp;gt; tips: 我这种判断MP4格式的方式实属异端，不建议模仿。&#xA;替换img标签 一到标签节点的操作，我第一想到的就是document操作（异端+1），直接上代码。&#xA;changeVideoTag(){ let videoTag = document.querySelector(&amp;#39;.video img&amp;#39;) console.log(&amp;#39;检测到应为video的img标签&amp;#39;, videoTag) if(videoTag){ let parentNode = videoTag.parentNode let newElement = document.createElement(&amp;#39;video&amp;#39;) newElement.setAttribute(&amp;#39;class&amp;#39;, videoTag.getAttribute(&amp;#39;class&amp;#39;)) newElement.setAttribute(&amp;#39;src&amp;#39;, videoTag.getAttribute(&amp;#39;src&amp;#39;)) parentNode.insertBefore(newElement, videoTag) } }, 该函数负责寻找video类下的img标签，然后在img标签之前，添加一个同样的videos元素节点，此处你可以选择是否移除原img标签。&#xA;最终实现效果 最后的话 这种方法非常不推荐使用，强烈建议使用自定义模板缩略图&#xA;这种方法非常不推荐使用，强烈建议使用自定义模板缩略图</description>
    </item>
    <item>
      <title>uni-app编译时删除指定文件夹</title>
      <link>http://localhost:1313/post/859_uni-app%E7%BC%96%E8%AF%91%E6%97%B6%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9/</link>
      <pubDate>Thu, 18 Jun 2020 11:25:31 +0000</pubDate>
      <guid>http://localhost:1313/post/859_uni-app%E7%BC%96%E8%AF%91%E6%97%B6%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9/</guid>
      <description>remove-files-webpack-plugin 原理就是在项目中添加一个webpack插件，然后配置插件&#xA;项目根目录新增vue.config.js&#xA;const path = require(&amp;#39;path&amp;#39;) const RemovePlugin = require(&amp;#39;remove-files-webpack-plugin&amp;#39;) module.exports = { configureWebpack: { plugins: [ new RemovePlugin({ after: { root: path.join(__dirname, &amp;#39;./unpackage&amp;#39;), include: [ path.join(__dirname, &amp;#39;unpackage/dist&amp;#39;, process.env.NODE_ENV === &amp;#39;production&amp;#39; ? &amp;#39;build&amp;#39; : &amp;#39;dev&amp;#39;, process.env .UNI_PLATFORM, &amp;#39;./mp-weixin/static/APPPIC&amp;#39;) ], trash: false } }) ] } } 部分webpack类似的webpack插件&#xA;copy-webpack-plugin&#xA;clean-webpack-plugin</description>
    </item>
    <item>
      <title>H5自适应页面的一种可行性方案</title>
      <link>http://localhost:1313/post/830_h5%E8%87%AA%E9%80%82%E5%BA%94%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%A1%8C%E6%80%A7%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sun, 19 Apr 2020 11:04:43 +0000</pubDate>
      <guid>http://localhost:1313/post/830_h5%E8%87%AA%E9%80%82%E5%BA%94%E9%A1%B5%E9%9D%A2%E7%9A%84%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%A1%8C%E6%80%A7%E6%96%B9%E6%A1%88/</guid>
      <description>前言 由于各种终端屏幕风格，大小迥异，由此而生衍生出了自适应页面设计。如果我们需要在各种机型上显示的风格比例一致，而解决屏幕大小不同显示内容不同的问题的话，我们需要对各种屏幕比例做适配。本文就该问题分享一种可行性方案。&#xA;由于以前做的移动端页面大部分为小程序页面，小程序采用相对像素(rpx)实现响应式适配。故本文也采用类似思想(rem)。&#xA;1. rem是什么 在W3C官网上是这样描述rem的——“font size of the root element”&#xA;即相对根节点（html)的字体大小,那么解决方案的思路就立马来了。根据不同的屏幕大小，设置不同的html字体大小，这样其他使用rem单位的元素即会随之自适应的改变大小。&#xA;2. 计算根节点(html)字体大小 2.1 JS方案 思路就是使用js获取窗口宽度，然后根据宽度计算对应的font-size。根据一般常识，js为了不影响页面体验，应在文档末尾添加。但此处为了避免HTML渲染完成后，使用JS动态修改字体而造成的页面抖动问题。我们应该将该JS元素节点放置于header底部，并内联到html文档里面。例如&#xA;在Vue中直接修改template.html即可&#xA;&amp;lt;script type=&amp;#34;text/javascript&amp;#34;&amp;gt; (function (doc, win) { var docEl = doc.documentElement, resizeEvt = &amp;#39;orientationchange&amp;#39; in window ? &amp;#39;orientationchange&amp;#39; : &amp;#39;resize&amp;#39;, recalc = function () { var clientWidth = docEl.clientWidth; docEl.style.fontSize = 100 * (clientWidth / 750) + &amp;#39;px&amp;#39;; }; if (!doc.addEventListener) { return; } win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(&amp;#39;DOMContentLoaded&amp;#39;, recalc, false); recalc() })(document, window) &amp;lt;/script&amp;gt; 该代码段监听页面尺寸改变事件，根据对应窗口大小(clientWidth)除以一个基准(750),进而调整html的font-size。在本例下，375的屏幕中1rem=50px。</description>
    </item>
    <item>
      <title>让你的网站防广告屏蔽</title>
      <link>http://localhost:1313/post/816_%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E9%98%B2%E5%B9%BF%E5%91%8A%E5%B1%8F%E8%94%BD/</link>
      <pubDate>Tue, 14 Apr 2020 20:02:18 +0000</pubDate>
      <guid>http://localhost:1313/post/816_%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E9%98%B2%E5%B9%BF%E5%91%8A%E5%B1%8F%E8%94%BD/</guid>
      <description>前言 相信小伙伴们对广告是又爱又恨，一方面不想接受广告的荼毒，另一方面也想接点广告赚点流量收益。由此而来衍生出了两个技术，屏蔽广告与防屏蔽广告。&#xA;屏蔽广告&#xA;防屏蔽&#xA;原理 我们要想做到网站广告不被人屏蔽，首先就要理解屏蔽广告的原理。&#xA;1.初阶屏蔽 含ad，推广等字样的js或者class类就直接拦截或者不显示&#xA;2.高阶屏蔽 我也不会，但是高阶屏蔽肯定是可以屏蔽低阶广告的。&#xA;那么根据这个原理，我们可以发现。只要我们写一个很low很low的广告，然后监听它是否成功加载，如果没有，则跳转页面或者不显示内容。&#xA;实现 1. 制造广告 先写一个一眼就能看出来是广告的js文件，例如把js文件名命名&#xA;为&amp;quot;adview_pic_cpc_cpm_cpa_guanggao_gg_ads_300x250.js&amp;quot;。广告二字赤裸裸的写着，广告的韵味呼之欲出。&#xA;2. 定义变量 在js里面定义一个变量，比如：&#xA;var adskilltest=true; 3. 监听广告变量 页面文件中读取该变量&#xA;不管怎么样，只要被拦截，那就肯定是undefined。让个极其肤浅的广告命名，来检测是否有屏蔽广告，这叫引蛇出洞！&#xA;大功告成！&#xA;4. 后续操作 既然被拦截，就要做出点反应。有了反应之后呢，还需要保存当时浏览的页面连接。我的解决方法是写一个noads.html负责显示被拦截后的内容以及保存跳转前的链接。&#xA;&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34;&amp;gt; &amp;lt;title&amp;gt;温馨提示&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p&amp;gt;网站内容被识别为广告，已被屏蔽。请禁用广告屏蔽后点击下面链接哦！&amp;lt;/p&amp;gt; &amp;lt;a href=&amp;#34;#&amp;#34; id=&amp;#34;a&amp;#34;&amp;gt;我已关闭广告屏蔽功能&amp;lt;/a&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; function getQueryVariable(variable) { var query = window.location.search.substring(1); var vars = query.split(&amp;#34;&amp;amp;&amp;#34;); for (var i=0;i&amp;lt;vars.length;i++) { var pair = vars[i].split(&amp;#34;=&amp;#34;); if(pair[0] == variable){return pair[1];} } return(false); } document.</description>
    </item>
    <item>
      <title>视差滚动</title>
      <link>http://localhost:1313/post/443_%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8/</link>
      <pubDate>Tue, 18 Feb 2020 18:39:29 +0000</pubDate>
      <guid>http://localhost:1313/post/443_%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8/</guid>
      <description>水平案例 </description>
    </item>
    <item>
      <title>【leetcode】5. Longest Palindromic Substring最长回文子串</title>
      <link>http://localhost:1313/post/730__leetcode_5_-longest-palindromic-substring%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Thu, 06 Feb 2020 14:43:58 +0000</pubDate>
      <guid>http://localhost:1313/post/730__leetcode_5_-longest-palindromic-substring%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>解法1：中心拓展算法 思路 首先，我们知道回文串一定是对称的，所以我们可以选择一个对称中心，进行左右扩展，判断左右字符是否相等即可。&#xA;由于存在奇数的字符串和偶数的字符串，所以我们需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 n+n-1 个中心。&#xA;实现代码 class Solution: def longestPalindrome(self, s: str) -&amp;gt; str: n = len(s) Max,sub = 0,s[0:1] for i in range(n): tmp = self.searchPalindrome(i-1,i+1,s) if len(tmp) &amp;gt; Max: Max = len(tmp) sub = tmp tmp = self.searchPalindrome(i-1,i,s) if len(tmp) &amp;gt; Max: Max = len(tmp) sub = tmp return sub def searchPalindrome(self, left: int, right: int, s: str) -&amp;gt; int: sub = &amp;#34;&amp;#34; while left != -1 and right !</description>
    </item>
    <item>
      <title>manacher（马拉车）算法讲解</title>
      <link>http://localhost:1313/post/737_manacher_%E9%A9%AC%E6%8B%89%E8%BD%A6_%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/</link>
      <pubDate>Fri, 31 Jan 2020 19:11:29 +0000</pubDate>
      <guid>http://localhost:1313/post/737_manacher_%E9%A9%AC%E6%8B%89%E8%BD%A6_%E7%AE%97%E6%B3%95%E8%AE%B2%E8%A7%A3/</guid>
      <description></description>
    </item>
    <item>
      <title>【leetcode】4. Median of Two Sorted Arrays寻找两个有序数组的中位数</title>
      <link>http://localhost:1313/post/726__leetcode_4_-median-of-two-sorted-arrays%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD/</link>
      <pubDate>Wed, 22 Jan 2020 09:50:15 +0000</pubDate>
      <guid>http://localhost:1313/post/726__leetcode_4_-median-of-two-sorted-arrays%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD/</guid>
      <description>我的初次实现 class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&amp;gt; float: newList = nums1 + nums2 newList.sort() result = 0 if(len(newList)%2 != 0) : result = newList[math.ceil(len(newList)/2-1)] else: index = int(len(newList)/2) result = (newList[index] + newList[index-1])/2 return result 成果 问题 但是我们仔细观察，可以发现这个的时间复杂度是不够的。</description>
    </item>
    <item>
      <title>【leetcode】2. Add Two Numbers两数相加</title>
      <link>http://localhost:1313/post/714__leetcode_2_-add-two-numbers%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Thu, 16 Jan 2020 21:42:10 +0000</pubDate>
      <guid>http://localhost:1313/post/714__leetcode_2_-add-two-numbers%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>描述 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。&#xA;如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。&#xA;您可以假设除了数字 0 之外，这两个数都不会以 0 开头。&#xA;示例：&#xA;输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) 输出：7 -&amp;gt; 0 -&amp;gt; 8 原因：342 + 465 = 807 思路 我看到这个题的第一感觉就是用递归把数获取出来，然后再相加，之后再把得数结构化。问题就被细分为了两个方面：&#xA;加数的提取&#xA;得数的结构化&#xA;我的初次实现 class Solution: def getStr(self,node: ListNode) -&amp;gt; str: if node.next == None: return node.val else: last = self.getStr(node.next) return str(last) + str(node.val) def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&amp;gt; ListNode: num1 = self.</description>
    </item>
    <item>
      <title>【leetcode】3. Longest Substring Without Repeating Characters无重复字符的最长子串</title>
      <link>http://localhost:1313/post/721__leetcode_3_-longest-substring-without-repeating-c/</link>
      <pubDate>Thu, 16 Jan 2020 21:41:34 +0000</pubDate>
      <guid>http://localhost:1313/post/721__leetcode_3_-longest-substring-without-repeating-c/</guid>
      <description>思路 查找无重复的字符子串，然后滑动窗口&#xA;初次解 每次滑动一格窗口&#xA;class Solution: def isUnique(self, s: str) -&amp;gt; bool: for ch in s: if s.count(ch) &amp;gt; 1: return False else: continue return True def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: i,j,Max=0,0,0 j+=1 while j &amp;lt;= len(s): if self.isUnique(s[i:j]): print(s[i:j],&amp;#34;is Unique&amp;#34;,i,j) Max=max(j-i,Max) j+=1 else: i+=1 return Max 成果 第一次优化 class Solution: def lengthOfLongestSubstring(self, s: str) -&amp;gt; int: if(len(s)==1): return 1 i,j,Max=0,0,0 while j &amp;lt;= len(s): st = s[i:j+1] if(j+1 &amp;lt; len(s)): index = st.</description>
    </item>
    <item>
      <title>【leetcode】1. two sum两数之和</title>
      <link>http://localhost:1313/post/295__leetcode_1_-two-sum%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Wed, 15 Jan 2020 10:12:10 +0000</pubDate>
      <guid>http://localhost:1313/post/295__leetcode_1_-two-sum%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>Description Given an array of integers, return indices of the two numbers such that they add up to a specific target.&#xA;You may assume that each input would have exactly one solution, and you may not use the same element twice.&#xA;Example:&#xA;Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 0. My solution(Brute Force) var twoSum = function(nums, target) { for(let i = 0; i &amp;lt; nums.</description>
    </item>
    <item>
      <title>docker容器的自定义修改并重新构建镜像</title>
      <link>http://localhost:1313/post/703_docker%E5%AE%B9%E5%99%A8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%AE%E6%94%B9%E5%B9%B6%E9%87%8D%E6%96%B0%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/</link>
      <pubDate>Thu, 02 Jan 2020 16:19:54 +0000</pubDate>
      <guid>http://localhost:1313/post/703_docker%E5%AE%B9%E5%99%A8%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%AE%E6%94%B9%E5%B9%B6%E9%87%8D%E6%96%B0%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/</guid>
      <description>前言 在上篇文章中，我们已经实现了VS code的无缝连接docker，却依旧存在着一些问题。比如它需要安装pylint方便调试，但是每次stop 容器之后，重新启动又需要重新安装，不可谓不麻烦。而且我发现它也需要重新安装VS code server,这是一个严重影响生产力的过程。所以目前的需求就变了如何作一些自定义的修改，并让这些修改永久性的保存。那答案当然是自定义的构建镜像啦，它可以让我们在构建的实践使用容器的过程中，将所做的更新持续化保存到自定义镜像。&#xA;自定义修改 在这里，我手动做了两个修改，一个是安装pylint，一个是更新pip。&#xA;提交更改 docker commit -m=&amp;#34;install pylint&amp;#34; -a=&amp;#34;chauncey&amp;#34; tf chauncey/tf 如上命令，将所有对容器的操作都保存至自定义镜像chauncey/tf 中。&#xA;测试效果 停止当前容器 docker stop tf 使用自定义镜像创建容器 docker run --gpus all -itd --name tf --rm -v ~/Project:/root/Project chauncey/tf 使用VS code远程连接，观察pip版本和pylint的安装情况。 如上图，我们发现pip已经是最新的版本。而且细心小伙伴会发现，连接容器时以及没有了install Dev container的提示了，这说明我们的VS code也已经预设安装进了镜像。</description>
    </item>
    <item>
      <title>Vscode无缝连接docker支持与主机文件同步</title>
      <link>http://localhost:1313/post/692_vscode%E6%97%A0%E7%BC%9D%E8%BF%9E%E6%8E%A5docker%E6%94%AF%E6%8C%81%E4%B8%8E%E4%B8%BB%E6%9C%BA%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Thu, 02 Jan 2020 15:46:08 +0000</pubDate>
      <guid>http://localhost:1313/post/692_vscode%E6%97%A0%E7%BC%9D%E8%BF%9E%E6%8E%A5docker%E6%94%AF%E6%8C%81%E4%B8%8E%E4%B8%BB%E6%9C%BA%E6%96%87%E4%BB%B6%E5%90%8C%E6%AD%A5/</guid>
      <description>为什么需要？ 我们在上一篇Ubuntu深度学习的相关配置中最后讲到，将工作目录下的文件装载到了容器之下，这样我们在主机中编写一个文件，如tf.py。在容器中执行，需要输入以下命令。&#xA;docker exec tf python &amp;#39;./tf.py&amp;#39; 这样每改一下文件，想要看效果的话，就需要输入以上命令。而且，还不方便调试。然后，我就在想能不能做到像我平常写代码那样，在VScode中，点一下就运行，而且可以调试呢？于是便有了本文。&#xA;准备工作 安装好VScode并且保证互联网连接正常。然后将工作目录装载到容器的/root/Project目录下，不然/tmp的文件实在是太乱七八糟了。 docker run --gpus all -itd --name tf --rm -v ~/Project:/root/Project tensorflow/tensorflow:latest-gpu-py3 操作流程 首先安装两个插件docker和Remote Development&#xA;上图中可以看到tensorflow的容器已经处于运行中了，然后再打开Remote Development&#xA;显示有一个容器待连接，然后选择它，打开容器中的Project文件夹&#xA;然后安装Python插件和调试工具，修改tf.py文件&#xA;import tensorflow as tf print(&amp;#34;hello tensorflow&amp;#34;) 点击右边的运行图标，成功输出。&#xA;打开主机文件&#xA;发现修改也已经同步，Over，现在可以愉快的写代码了。</description>
    </item>
    <item>
      <title>Ubuntu深度学习的相关配置</title>
      <link>http://localhost:1313/post/638_ubuntu%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Fri, 20 Dec 2019 22:06:35 +0000</pubDate>
      <guid>http://localhost:1313/post/638_ubuntu%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</guid>
      <description>安装NVIDIA驱动 查看显卡信息 ubuntu-drivers devices 自动安装显卡驱动 sudo ubuntu-drivers autoinstall 确认是否安装成功 nvidia-smi 安装docker 安装文档&#xA;使用阿里源安装&#xA;# step 1: 安装必要的一些系统工具 sudo apt-get update sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common # step 2: 安装GPG证书 curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - # Step 3: 写入软件源信息 sudo add-apt-repository &amp;#34;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&amp;#34; # Step 4: 更新并安装Docker-CE sudo apt-get -y update sudo apt-get -y install docker-ce # 安装指定版本的Docker-CE: # Step 1: 查找Docker-CE的版本: # apt-cache madison docker-ce # docker-ce | 17.</description>
    </item>
    <item>
      <title>Ubutnu使用问题记录贴</title>
      <link>http://localhost:1313/post/650_ubutnu%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E8%B4%B4/</link>
      <pubDate>Fri, 20 Dec 2019 19:52:13 +0000</pubDate>
      <guid>http://localhost:1313/post/650_ubutnu%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%E8%B4%B4/</guid>
      <description>安装软件未满足依赖关系 安装软件curl时提示以下内容&#xA;下列软件包有未满足的依赖关系： curl : 依赖: libcurl4 (= 7.64.0-2ubuntu1.2) 但是 7.65.3-1ubuntu3 正要被安装 E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。 这是由于版本不符的导致的，可能是以前卸载的时候未卸载干净。所以我们需要使用purge选项来重新卸载一次。&#xA;sudo apt-get purge libcurl4 然后重新安装，解决问题！！&#xA;执行bash命令提示bash: /dev/fd/63: 没有那个文件或目录 原因：&amp;lt;（…）运算符称为进程替换，是运行命令的一种方式，其输出进入匿名管道。这就是/dev/fd/63。其思想是允许外部命令（这里是bash）将另一个命令输出视为一个文件。通常形式是使用&amp;lt;将伪文件对象重定向到bash的输入流中。&#xA;解决方案，使用两个&amp;lt;&#xA;用户不在sudo列表 别问为什么出现这个问题，，，&#xA;解决方法 重启进恢复模式&#xA;选择root用户&#xA;添加用户至sudo组&#xA;adduser username sudo 系统没有设置图标 天哪，为啥我的电脑老是出现些奇怪的问题。&#xA;解决方法 -sudo apt update-&#xA;sudo apt install gnome-control-center</description>
    </item>
    <item>
      <title>Ubuntu使用阿里云加速docker pull</title>
      <link>http://localhost:1313/post/674_ubuntu%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A0%E9%80%9Fdocker-pull/</link>
      <pubDate>Thu, 19 Dec 2019 17:19:22 +0000</pubDate>
      <guid>http://localhost:1313/post/674_ubuntu%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%8A%A0%E9%80%9Fdocker-pull/</guid>
      <description>使用 Docker 时需要首先下载一个官方镜像，例如 mysql、wordpress。然而由于网络原因，下载一个 Docker 官方镜像可能会需要很长的时间，甚至下载失败。为此，阿里云容器镜像服务提供了官方的镜像站点，从而加速官方镜像的下载。&#xA;登陆阿里云容器镜像服务 由上图可以看到，阿里给我们分配的专享加速域名。&#xA;配置docker源 针对Docker客户端版本大于 1.10.0 的用户&#xA;可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器&#xA;不过默认没有这个文件的，所以我们需要新建一个&#xA;新建daemon.json sudo mkdir -p /etc/docker sudo touch /etc/docker/daemon.json 设置源地址 { &amp;#34;registry-mirrors&amp;#34;: [&amp;#34;&amp;lt;your accelerate address&amp;gt;&amp;#34;] } 重启生效 sudo systemctl daemon-reload sudo systemctl restart docker 大功吿成！！</description>
    </item>
    <item>
      <title>ubuntu安装后需要做的事情</title>
      <link>http://localhost:1313/post/26_ubuntu%E5%AE%89%E8%A3%85%E5%90%8E%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85/</link>
      <pubDate>Wed, 18 Dec 2019 16:51:26 +0000</pubDate>
      <guid>http://localhost:1313/post/26_ubuntu%E5%AE%89%E8%A3%85%E5%90%8E%E9%9C%80%E8%A6%81%E5%81%9A%E7%9A%84%E4%BA%8B%E6%83%85/</guid>
      <description>1. 安装chrome sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/ wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add - sudo apt update sudo apt install google-chrome-stable 19年12月18日：现在觉得火狐也不错&#xA;2. 安装Shadowsocks 不然美化界面太慢了&#xA;3. 美化界面参考链接 安装工具&#xA;sudo apt-get update sudo apt-get install gnome-tweak-tool sudo apt-get install gnome-shell-extensions sudo apt-get install gnome-shell-extension-dashtodock 3. 安装搜狗输入法ubuntu 18.04 LTS 安装搜狗输入法 实在是不喜欢默认输入法&#xA;4. 换阿里源 1. 先备份源 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 2. 删除原文件 sudo rm -f /etc/apt/sources.list 3. 新建源文件 sudo vi /etc/apt/sources.</description>
    </item>
    <item>
      <title>褪去铅华，理性的认识人工智能</title>
      <link>http://localhost:1313/post/632_%E8%A4%AA%E5%8E%BB%E9%93%85%E5%8D%8E_%E7%90%86%E6%80%A7%E7%9A%84%E8%AE%A4%E8%AF%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</link>
      <pubDate>Mon, 09 Dec 2019 12:46:51 +0000</pubDate>
      <guid>http://localhost:1313/post/632_%E8%A4%AA%E5%8E%BB%E9%93%85%E5%8D%8E_%E7%90%86%E6%80%A7%E7%9A%84%E8%AE%A4%E8%AF%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</guid>
      <description>## 引言 人工智能时代并未真正来临 弱人工智能与强人工智能 部分行业的受益 AI不等于全能 弱人工智能的原理 为什么最近几年才兴起人工智能 数据量的数字记录与硬件设备的飞速发展&#xA;那些让人工智能受挫的领域 </description>
    </item>
    <item>
      <title>无监督学习</title>
      <link>http://localhost:1313/post/629_%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Mon, 09 Dec 2019 12:22:26 +0000</pubDate>
      <guid>http://localhost:1313/post/629_%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</guid>
      <description>介绍 无监督学习允许我们在处理问题时几乎不知道结果应该是什么样子，我们可以从数据中获得结构，而不必知道变量的作用。我们可以根据数据中变量之间的关系对数据进行聚类，从而得到这种结构。在无监督学习中，没有基于预测结果的反馈。也就是说，机器可以在你提供的数据中主动的去分析，总共有几类？哪些数据属于什么类？</description>
    </item>
    <item>
      <title>线性回归算法</title>
      <link>http://localhost:1313/post/631_%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95/</link>
      <pubDate>Mon, 09 Dec 2019 12:17:46 +0000</pubDate>
      <guid>http://localhost:1313/post/631_%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95/</guid>
      <description>&gt; 经典例子：房价预测</description>
    </item>
    <item>
      <title>有监督学习中的回归问题与分类问题</title>
      <link>http://localhost:1313/post/475_%E6%9C%89%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98%E4%B8%8E%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 09 Dec 2019 11:57:50 +0000</pubDate>
      <guid>http://localhost:1313/post/475_%E6%9C%89%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%9B%9E%E5%BD%92%E9%97%AE%E9%A2%98%E4%B8%8E%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98/</guid>
      <description>What is Machine Learning? Two definitions of Machine Learning are offered.&#xA;Arthur Samuel described it as: &amp;ldquo;the field of study that gives computers the ability to learn without being explicitly programmed.&amp;rdquo; This is an older, informal definition.&#xA;Tom Mitchell provides a more modern definition: &amp;ldquo;A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.</description>
    </item>
    <item>
      <title>写一个图类</title>
      <link>http://localhost:1313/post/519_%E5%86%99%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%B1%BB/</link>
      <pubDate>Sat, 07 Dec 2019 22:07:40 +0000</pubDate>
      <guid>http://localhost:1313/post/519_%E5%86%99%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%B1%BB/</guid>
      <description>说到交通网路的模拟化表示，那就不得不用到数据结构中的图。想必这应该是最方便形象的表示方法了把。&#xA;图的概念 图是由顶点集合及顶点之间关系的集合组成的一种数据结构，Graph = （V，E）。&#xA;其中顶点集合V = { x | x ∈ 某个数据对象集}是个有穷非空集合。E = { &amp;lt;x, y&amp;gt; | x , y ∈ V &amp;amp;&amp;amp; Path( x , y )} ，即边集。&#xA;我所知的图的存储结构 邻接矩阵表示 邻接矩阵的表示，首先将所有的顶点信息组成一个表。然后利用一个矩阵来表示各顶点之间的相邻关系，称之为邻接矩阵。&#xA;邻接表表示 在第i行的单链表中，各节点（或称边节点）分别存放与同一个顶点Vi关联的各条边。各个节点配有其标识（及对应的顶点）和权值（若为有权图）以及指向另一个边节点的指针。&#xA;*邻接多重表表示 邻接多重表的表示，主要一处理图的边为主（为什么会有这个需求？在什么情况会用到？），要求每条边处理一次的实际应用中特别有用（比如？）。它的主要思想是把多重表结构引入到图的邻接表中，就有点像把边作为研究的基本单位，用一个多重表节点来表示一条边。&#xA;*十字链表表示 此为百度词条：十字链表（Orthogonal List)是有向图的另一种链式存储结构。该结构可以看成是将有向图的邻接表(和逆邻接表结合起来得到的。用十字链表来存储有向图，可以达到高效的存取效果。同时，代码的可读性也会得到提升。&#xA;我该选什么存储结构 首先，交通道路网络是双向的，所以我们可以将其视为无向图; 其次在一座城市的交通网络下，道路E 与路口 n的关系是 E &amp;laquo; n^2，而且道路是会出现两点之间多条路的情况（即多重图）所以我舍弃第一种方法; 后面两种表示方式其实我也是一知半解，我有种感觉，如果在交通道路的分层模型下，可能第三种方式要更具优势，但是目前还想不了那么远。所以我暂时选用第二种方式，用邻接表表示。&#xA;我的实现代码 (代码年久失修，已失去完整内容，仅供参考)&#xA;Graph_lnk.h // V1.0.1 pragma once # include using namespace std; int DefaultMaxVertices = 500; //最大顶点数 auto memory_error = [](char * function, string aim) { cerr &amp;lt;&amp;lt; function &amp;lt;&amp;lt; &amp;#34;申请&amp;#34; &amp;lt;&amp;lt; aim.</description>
    </item>
    <item>
      <title>大家好，我是醉月思 </title>
      <link>http://localhost:1313/post/570_%E5%A4%A7%E5%AE%B6%E5%A5%BD_%E6%88%91%E6%98%AF%E9%86%89%E6%9C%88%E6%80%9D/</link>
      <pubDate>Fri, 06 Dec 2019 12:06:48 +0000</pubDate>
      <guid>http://localhost:1313/post/570_%E5%A4%A7%E5%AE%B6%E5%A5%BD_%E6%88%91%E6%98%AF%E9%86%89%E6%9C%88%E6%80%9D/</guid>
      <description>大家好，我是醉月思。&#xA;为什么我叫&amp;quot;醉月思&amp;quot;呢？这要追溯到很久很久以前，大约还是我在读高二的某一天晚上，有位朋友告诉我：&amp;ldquo;你的名字好中二啊！&amp;quot;。&#xA;刹那间，我恍然大悟，我怎么叫了个这样的网名“银慧空狼”（话外音：我TM当时脑袋是瓦特了吗？起了个这样的名字！）。&#xA;于是我坐在台阶上苦思冥想，立誓要起一个符合我气质的名字，要让人家见名知意，然后知其人。终于，在我某一刻抬头仰望夜空之时，灵光一现！&#xA;便想到了“醉月思”这个网名。于是，我屁颠屁颠的将一个中二的网名进行了&amp;quot;二转&amp;rdquo;————变成了一个比较含蓄的中二网名。&#xA;看出来没？？引用当时一句比较潮的话，我也是醉了。。。从此，醉月思这个“二转”含蓄中二网名便陪我到现在。&#xA;直到我上大学，我突然意识到，有着自己独特的网名还不能凸显我的气质，我应该还得拥有一个属于自己的专属头像。&#xA;最开始，我使用的是这个头像。&#xA;后来，由于某些原因我需要换掉这个头像。我就找了一个我喜欢的动漫的男女主头像————我当时以为的男女主，因为初中看过之后就直接看到后面的剧情感觉怪怪的，所以就没怎么看。如下图&#xA;以后“醉月思”和这个头像就成了我的第二身份标识，下面，就是一些个人经历回忆。&#xA;时间线 2015年10月，编(chao)写了人生第一个程序a+b=c(居然不是hello world）。&#xA;2015年11月，人生第一个游戏编写成功，也是第一次发圈装逼&#xA;2016年6月，第一次使用C++做界面 2016年8月，第一次以醉月思的名义在CSDN上发表人生第一篇博客 2016年9月，第一次解除java，并试图反编译APP 2016年10月，第一次上线&amp;quot;拼图游戏&amp;quot; 2016年10月，注册个人公众号。 2016年10月，注册域名“thinkmoon.cn” 2016年12月，第一次搭建个人博客网站 2017年1月，第一次接触Linux，然后就把电脑装为linux了 2017年2月，第一次使用脚本语言爬取四六级成绩 2017年4月，第一次打算组建个Team来运营公众号 2017年6月，完成第一个&amp;quot;微信小程序&amp;quot;。 2017年7月，人生第一个软件上线。 2017年9月，开始熟悉JavaScript 接下来的有兴趣的去我博客看吧。 一些成果展示。 博客数据概览 篆书转换器小程序数据概览 指尖魔法屋公众号数据概览 博客收益数据概览 后记 我庆幸我有着写博客的习惯，算上这篇，博客文章加上水文，刚好凑够了100篇，当时我就在想，到了100篇，我一定要写点什么。现在看来，也算是半个百篇总结吧。最后，愿我可以将这个习惯坚持下去！&#xA;后后记 本来是想写一篇广告文的，写着写着就偏离了主题。文末打波广告，这是我最近开发的博客小程序，对接typecho的。大家有钱的点个赞赏捧个钱场，不想赞赏的扫码进入捧个人场？在此，我谢谢大家这几年来的支持和陪伴，愿我们彼此交流，共同成长！</description>
    </item>
    <item>
      <title>让微信小程序页面默认支持分享及返回操作</title>
      <link>http://localhost:1313/post/225_%E8%AE%A9%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E9%BB%98%E8%AE%A4%E6%94%AF%E6%8C%81%E5%88%86%E4%BA%AB%E5%8F%8A%E8%BF%94%E5%9B%9E%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 25 Nov 2019 12:53:22 +0000</pubDate>
      <guid>http://localhost:1313/post/225_%E8%AE%A9%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%A1%B5%E9%9D%A2%E9%BB%98%E8%AE%A4%E6%94%AF%E6%8C%81%E5%88%86%E4%BA%AB%E5%8F%8A%E8%BF%94%E5%9B%9E%E6%93%8D%E4%BD%9C/</guid>
      <description>为啥需要这个？ 有时候我们写微信小程序，写好了。在手机上运行感觉效果还不错，正想分享给别人。突然发现没有分享选项，纳尼？原来是忘记写onShareAppMessage()了。有得加上，再编译。不得不说，麻烦的一匹。&#xA;应运而生 然后我就想，要是可以让默认支持分享就好了。&#xA;wepy实现方法 大致思路 import wepy from &amp;#39;wepy&amp;#39;; export default class Page extends wepy.page { } 分析代码，发现所有的page都继承于wepy.page, 而wepy.page又继承于wepy.component. 这感情好。也就意味着我只需要构建一个超类继承wepy.page就可以了&#xA;实践 新建page.js文件，内容如下&#xA;import wepy from &amp;#39;wepy&amp;#39;; export default class Page extends wepy.page { onShareAppMessage() { } } 然后再调整一下页面继承&#xA;import Page from &amp;#39;../page&amp;#39;; export default class Index extends Page { } 编译运行，果然如此！&#xA;如果要自定义分享内容怎么办？ 在子page里面重构onShareAppMessage就可以啦。&#xA;tips: 现使用uni-app后发现已经默认支持分享了&#xA;后续： uni-app说这是个BUG，已经修复了。。 后备方案——使用mixin全局混入 在main.js中添加以下内容。 import qs from &amp;#39;query-string&amp;#39; Vue.mixin({ onShareAppMessage() { console.log(&amp;#39;分享路径&amp;#39;, &amp;#39;/pages/index?route=&amp;#39; + this.</description>
    </item>
    <item>
      <title>uni-app使用fly封装网络请求接口</title>
      <link>http://localhost:1313/post/306_uni-app%E4%BD%BF%E7%94%A8fly%E5%B0%81%E8%A3%85%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Fri, 22 Nov 2019 15:55:32 +0000</pubDate>
      <guid>http://localhost:1313/post/306_uni-app%E4%BD%BF%E7%94%A8fly%E5%B0%81%E8%A3%85%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3/</guid>
      <description>介绍 本文采用uni-app框架开发，使用flyio库封装请求。&#xA;安装方式 npm install --save flyio 引入方式 新建api.js文件，编写以下内容&#xA;var Fly = require(&amp;#34;flyio/dist/npm/wx&amp;#34;) var fly = new Fly; 配置方式 // 配置请求根域名 fly.config.baseURL = &amp;#34;http://whisper.wezoz.com&amp;#34; // 配置响应拦截器 fly.interceptors.response.use( (response) =&amp;gt; { // 如果请求报错 if (response.data.code != 10000) { uni.showModal({ title:&amp;#39;温馨提示&amp;#39;, content:response.data.data }) }else{ //只将请求结果的data字段返回 return response.data.data } }, (err) =&amp;gt; { //发生网络错误后会走到这里 return Promise.resolve(&amp;#34;网络请求：ERROR！&amp;#34;) } ) // 配置请求拦截器 fly.interceptors.request.use((request) =&amp;gt; { request.headers[&amp;#34;token&amp;#34;] = uni.getStorageSync(&amp;#39;token&amp;#39;); return request; }) 同步封装微信登录 async function wxLogin() { return await new Promise((resolve, reject) =&amp;gt; { wx.</description>
    </item>
    <item>
      <title>百度与谷歌的差距在哪？</title>
      <link>http://localhost:1313/post/448_%E7%99%BE%E5%BA%A6%E4%B8%8E%E8%B0%B7%E6%AD%8C%E7%9A%84%E5%B7%AE%E8%B7%9D%E5%9C%A8%E5%93%AA_/</link>
      <pubDate>Thu, 21 Nov 2019 11:21:53 +0000</pubDate>
      <guid>http://localhost:1313/post/448_%E7%99%BE%E5%BA%A6%E4%B8%8E%E8%B0%B7%E6%AD%8C%E7%9A%84%E5%B7%AE%E8%B7%9D%E5%9C%A8%E5%93%AA_/</guid>
      <description>&#xA;前言 最开始是没有搜索引擎的，后来有了谷歌，也就有了搜索引擎。但别人却一直模仿不过来，直到谷歌公布了三篇论文，然后有了百度。&#xA;时至今日，谷歌与百度已经不单单是搜索引擎了，始于搜索引擎，但又都不止于搜索引擎，但是谷歌却一直在被模仿从未被超越。所以百度与谷歌的差距究竟在哪呢？&#xA;搜索引擎 个人在使用两家的搜索引擎有个很明显的感觉，百度能搜到的内容少而单一，谷歌则好些。但这还有一部分原因是GFW，被GFW拦住的网站，是注定在百度排不上号的。所以内容少并不能完全怪百度。内容重复或者参考价值不大的情况两个平台都有,百度结果比较多文章转载的,而谷歌则经常出现各种搜索集合网站,如下&#xA;做这些产业的人,都已经非常熟悉搜索引擎的规则, 纯粹的营销网站罢了.这个也很难避免,有搜索规则就有人能摸索出来(顺便一提,我的网站怎么老是排不上名呢)&#xA;未完待续 </description>
    </item>
    <item>
      <title>交通网络分层设计模型之路口状态</title>
      <link>http://localhost:1313/post/516_%E4%BA%A4%E9%80%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%B7%AF%E5%8F%A3%E7%8A%B6%E6%80%81/</link>
      <pubDate>Tue, 19 Nov 2019 17:10:06 +0000</pubDate>
      <guid>http://localhost:1313/post/516_%E4%BA%A4%E9%80%9A%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B%E4%B9%8B%E8%B7%AF%E5%8F%A3%E7%8A%B6%E6%80%81/</guid>
      <description>所有的路口标号用int road[8]表示，&#xA;用bool status[8][8]表示道路可否通行。&#xA;T字路口 对于T字路口，将道路分为（左，右，下）三个流量出入口，存在的状态有：&#xA;0. 全红(特殊状态应对突发事故） for (int i = 0; i &amp;lt; 8; i++) { for (int j = 0; j &amp;lt; 8; j++) { status[i][j] = false; } } ×|0|1|2|3|4|5&#xA;:&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: |&#xA;0|×|×|×|×|×|×&#xA;1|×|×|×|×|×|×&#xA;2|×|×|×|×|×|×&#xA;3|×|×|×|×|×|×&#xA;4|×|×|×|×|×|×&#xA;5|×|×|×|×|×|×&#xA;正常状态下考虑红灯可右转，同向变道不受交通灯控制，即永远可通行&#xA;status[2][1] = status[4][3] = true; status[0][1] = status[2][3] = status[4][5] = true; ×|0|1|2|3|4|5&#xA;:&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: |</description>
    </item>
    <item>
      <title>机器视觉入门（1）</title>
      <link>http://localhost:1313/post/526_%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%85%A5%E9%97%A8_1_/</link>
      <pubDate>Mon, 28 Oct 2019 17:35:57 +0000</pubDate>
      <guid>http://localhost:1313/post/526_%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E5%85%A5%E9%97%A8_1_/</guid>
      <description>遇到的一些问题 Imageio: &amp;lsquo;ffmpeg-linux64-v3.3.1&amp;rsquo; was not found on your computer; downloading it now.&#xA;解决办法：&#xA;sudo add-apt-repository -y ppa:djcj/hybrid &amp;amp;&amp;amp; sudo apt update &amp;amp;&amp;amp; sudo apt install -y ffmpeg&#xA;我直接运行了，然后它自动下载安装了。</description>
    </item>
    <item>
      <title>我的神奇笔记</title>
      <link>http://localhost:1313/post/525_%E6%88%91%E7%9A%84%E7%A5%9E%E5%A5%87%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 28 Oct 2019 17:33:35 +0000</pubDate>
      <guid>http://localhost:1313/post/525_%E6%88%91%E7%9A%84%E7%A5%9E%E5%A5%87%E7%AC%94%E8%AE%B0/</guid>
      <description> 唔，这个配色是我乱打然后筛选出来较为柔和的配色&#xA;&amp;lt;font&#xA;color=&amp;quot;#616161&amp;quot;&#xA;id=&amp;ldquo;9116994572745c660f40296d7683c991cd273cca&amp;rdquo;&amp;gt;&#xA;字体色#616161 前景色:#EFEFEF&#xA;背景色:#FF6666 前景色:#EEEEEE&#xA;背景色:#55EF55 前景色:##E5E5E5&#xA;背景色:#554455 </description>
    </item>
    <item>
      <title>实训项目后记</title>
      <link>http://localhost:1313/post/523_%E5%AE%9E%E8%AE%AD%E9%A1%B9%E7%9B%AE%E5%90%8E%E8%AE%B0/</link>
      <pubDate>Mon, 28 Oct 2019 17:31:21 +0000</pubDate>
      <guid>http://localhost:1313/post/523_%E5%AE%9E%E8%AE%AD%E9%A1%B9%E7%9B%AE%E5%90%8E%E8%AE%B0/</guid>
      <description>项目开始于2018/10/26, 本来已经申请免听了， 这几天好难受, 刚开始打算就随便从github上modify一个， 后来找来找去没发现合适的， 再加上有点皮，就开始了几天的程序猿模式。&#xA;github项目地址 申明: 项目由基于Vue+Vuex+iView的电子商城网站 修改而来&#xA;由于各种原因未在github地址上补充上述内容，在此补上。</description>
    </item>
    <item>
      <title>原项目代码分析</title>
      <link>http://localhost:1313/post/522_%E5%8E%9F%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 28 Oct 2019 17:30:13 +0000</pubDate>
      <guid>http://localhost:1313/post/522_%E5%8E%9F%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>原项目代码类图&#xA;各类文件解析（按难度排序）&#xA;&amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Point (坐标类，使用经度，维度用来表示一个点) Point.h&#xA;&amp;lt;li&amp;gt; # &amp;lt;li&amp;gt; pragma once class Point { &amp;lt;li&amp;gt; public: Point(double longitude, double latitdue); &amp;lt;li&amp;gt; bool operator == (Point &amp; point); &amp;lt;li&amp;gt; private: double longitude; //经度 &amp;lt;li&amp;gt; double latitude; //纬度 &amp;lt;li&amp;gt; }; &amp;lt;li&amp;gt;&amp;lt;strong&amp;gt;Road(道路类，使用两个点来表示一条道路) Road.h&#xA;&amp;lt;li&amp;gt; # &amp;lt;li&amp;gt; pragma once# include &#34;stdafx.h&#34;# &amp;lt;li&amp;gt; include &#34;Point.h&#34;# &amp;lt;li&amp;gt; include &#34;Vehicle.h&#34;# &amp;lt;li&amp;gt; include &#34;TrafficLight.h&#34;# &amp;lt;li&amp;gt; include &#34;BitMatrix.h&#34;# &amp;lt;li&amp;gt; define R 6378 //地球的平均半径 &amp;lt;li&amp;gt; # define PI 3.14# define LANNE_AMOUNT 3 //每条道路的车道数量 &amp;lt;li&amp;gt; # define MIN_VEHICLE 10 //初始状态每条道路的最少车辆 &amp;lt;li&amp;gt; # define VEHICLE_SIZE 70 class Vehicle; &amp;lt;li&amp;gt; class TrafficLight; &amp;lt;li&amp;gt; class Road { &amp;lt;li&amp;gt; public: Road(double longitude1, double latitude1, double longitude2, double latitude2): point1(longitude1, latitude1), point2(longitude2, latitude2) { &amp;lt;li&amp;gt; length = R * 2 * asin(sqrt(pow(sin((latitude1 / 180 * PI - latitude2 / 180 * PI) / 2), 2) + cos(latitude1 / 180 * PI) * cos(latitude2 / 180 * PI) * pow(sin((longitude1 / 180 * PI - longitude2 / 180 * PI) / 2), 2))); //计算道路长度 &amp;lt;li&amp;gt; } &amp;lt;li&amp;gt; bool operator == (Road &amp; road); //用于判断两条道路是否相连 &amp;lt;li&amp;gt; double countVehicleDensity(void); //计算行车密度， 行车密度 = 车辆数 / (道路长度(km) * 车道数） &amp;lt;li&amp;gt; double countCrowdExtent(void); //计算道路拥挤度 &amp;lt;li&amp;gt; double returnLength(void); //返回道路长度 &amp;lt;li&amp;gt; bool enterVehicle(void); //当前道路是否能进车 &amp;lt;li&amp;gt; void updateVehicle(vector &lt; Road &gt; &amp; road); //更新当前道路的车辆 &amp;lt;li&amp;gt; void creatVehicle(int roadSize, int totalRoadSize, BitMatrix &amp; roadBitMatrix, vector &lt; Road &gt; &amp; road); //为该道路生成车辆 &amp;lt;li&amp;gt; void enterVehicle(Vehicle &amp; vehicle); //进入车辆 &amp;lt;li&amp;gt; void updateTrafficLight(void); //更新当前道路的交通灯 &amp;lt;li&amp;gt; /* 计算拥挤度的公式: crowdExtent = 0.</description>
    </item>
    <item>
      <title>初探JavaFx</title>
      <link>http://localhost:1313/post/520_%E5%88%9D%E6%8E%A2javafx/</link>
      <pubDate>Mon, 28 Oct 2019 17:28:36 +0000</pubDate>
      <guid>http://localhost:1313/post/520_%E5%88%9D%E6%8E%A2javafx/</guid>
      <description>IDEA下开发JavaFx Application New &amp;gt; project &amp;gt; JavaFx Application&#xA;添加SceneBuilder 下载SceneBuilder file | setting &amp;gt; JavaFx &amp;gt; add path 设置自定义图标 primaryStage.getIcons().add(new Image(&amp;quot;file:res/internet.png&amp;quot;));&#xA;打包生成exe File | project structure &amp;gt; Artifacts &amp;gt; JavaFx &amp;gt;(class | title | Navite Bundle)&#xA;注意目录文件要能找到&#xA;事件绑定 fxml&#xA;onAction add&#xA;Java&#xA;添加函数&#xA;fx:id 对象属性修改 添加一个fxml成员变量 调用setText(&amp;quot;&amp;quot;); 我的代码 MainApp.fxml&#xA;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;?import javafx.geometry.Insets?&amp;gt; &amp;lt;?import javafx.scene.control.Button?&amp;gt; &amp;lt;?import javafx.scene.control.DialogPane?&amp;gt; &amp;lt;?import javafx.scene.control.Label?&amp;gt; &amp;lt;?import javafx.scene.control.TextArea?&amp;gt; &amp;lt;?import javafx.scene.control.TextField?&amp;gt; &amp;lt;?import javafx.scene.layout.FlowPane?&amp;gt; &amp;lt;?import javafx.scene.layout.Pane?&amp;gt; &amp;lt;?import javafx.scene.text.Font?&amp;gt; &amp;lt;FlowPane maxHeight=&amp;#34;-Infinity&amp;#34; maxWidth=&amp;#34;-Infinity&amp;#34; minHeight=&amp;#34;-Infinity&amp;#34; minWidth=&amp;#34;-Infinity&amp;#34; prefHeight=&amp;#34;400.</description>
    </item>
    <item>
      <title>使用wepy &#43; 微信小程序云开发做一个不用服务器的小程序</title>
      <link>http://localhost:1313/post/518_%E4%BD%BF%E7%94%A8wepy-_-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%8D%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/</link>
      <pubDate>Mon, 28 Oct 2019 17:26:18 +0000</pubDate>
      <guid>http://localhost:1313/post/518_%E4%BD%BF%E7%94%A8wepy-_-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%E5%81%9A%E4%B8%80%E4%B8%AA%E4%B8%8D%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/</guid>
      <description>技术介绍 Wepy 云开发 开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。&#xA;云开发为开发者提供完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。&#xA;目前提供三大基础能力支持：&#xA;云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码&#xA;数据库：一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库&#xA;存储：在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理&#xA;安装WePy WePY的安装或更新都通过npm进行。&#xA;如果你未安装过npm，你可能需要先安装npm&#xA;npm install wepy-cli -g 注: 我这使用的版本是&#xA;创建一个WePy项目 首先，查看一下项目模板 wepy list 他会在这里列出一些模板，你选择你喜欢的安装。&#xA;wepy init standard my-project</description>
    </item>
    <item>
      <title>vue的相关问题</title>
      <link>http://localhost:1313/post/515_vue%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 28 Oct 2019 17:23:06 +0000</pubDate>
      <guid>http://localhost:1313/post/515_vue%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid>
      <description>安装nodejs sudo apt-get install nodejs 安装npm sudo apt install npm 改镜像源 sudo npm config set registry https://registry.npm.taobao.org sudo npm config list 升级node sudo npm i -g n sudo n stable 安装Vue npm install -g @vue/cli 引入less文件失败 安装less，和less-loader&#xA;npm i --save less less-loader&#xA;iview自定义主题失败 两个解决方案&#xA;less降级为3以下，比如2.7.3&#xA;配置vue.config.js(未实践）&#xA;module.exports = { css: { // 配置css模块 loaderOptions: { // 向预处理器 Loader 传递配置选项 less: { // 配置less（其他样式解析用法一致） javascriptEnabled: true // 设置为true } } } } 报错 ERROR in .</description>
    </item>
    <item>
      <title>进化版的Server酱——PushBear</title>
      <link>http://localhost:1313/post/509_%E8%BF%9B%E5%8C%96%E7%89%88%E7%9A%84server%E9%85%B1__pushbear/</link>
      <pubDate>Mon, 28 Oct 2019 17:16:07 +0000</pubDate>
      <guid>http://localhost:1313/post/509_%E8%BF%9B%E5%8C%96%E7%89%88%E7%9A%84server%E9%85%B1__pushbear/</guid>
      <description>一个利用PHP群发微信消息的工具。上一篇讲到了如何用Server酱推送消息到个人微信，这篇我们一起来了解一下Server酱的进化版——pushbear，一对多微信消息推送&#xA;Server酱的局限 ==首先这里的SCKEY与userID只是简单的一对一的关系，但其实如果做成一对多更好。因为这样便可以群发通知 #801400==&#xA;==她这儿的的分享链接里面包含了很多个人敏感的信息，而其实这在微信的标准里面是不安全的。 #801900==&#xA;老规矩，PushBear官网(https://pushbear.ftqq.com/admin/#/) 使用流程 1.使用微信扫码登录网站&#xA;这个比Server好的地方就是它不需要使用github账号登录了，直接扫码即可。&#xA;2.新建通道&#xA;这里的通道的意思你可以把它，看作一个群。每一个通道负责群发消息到绑定这个管道 的微信。&#xA;3.绑定用户到通道&#xA;这个也特别的方便，直接扫描订阅二维码即可&#xA;4.发送测试消息&#xA;打开测试表单啦，然后测试&#xA;5.使用PHP群发消息到微信&#xA;一个函数就可以了，&#xA;function weixin_notify($header,$content){ $SENDKEY = &amp;#34;1218-f6*************0b98d0a2e10fdd2&amp;#34;;//微信通知KEY file_get_contents(&amp;#39;https://pushbear.ftqq.com/sub?sendkey=&amp;#39;.$SENDKEY.&amp;#39;&amp;amp;text=&amp;#39;.urlencode($header).&amp;#39;&amp;amp;desp=&amp;#39;.urlencode($content)); } 6.效果展示&#xA;总结 原理什么的，这次就不解释了，上一篇已经解释过了。&#xA;现在我们已经可以利用Server酱发送服务器报警消息至开发者微信。&#xA;然后再利用PushBear群发业务消息到用户微信。完美对接业务以及管理逻辑。&#xA;是不感觉特别的方便？</description>
    </item>
    <item>
      <title>Deepin安装微信开发者工具</title>
      <link>http://localhost:1313/post/507_deepin%E5%AE%89%E8%A3%85%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 28 Oct 2019 17:14:44 +0000</pubDate>
      <guid>http://localhost:1313/post/507_deepin%E5%AE%89%E8%A3%85%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/</guid>
      <description>我们都知道，微信开发者工具是没有linux版的，还是有点难受。好在有大神迁移了。&#xA;1. 下载项目 git clone https://github.com/cytle/wechat_web_devtools.git 2. 进入目录 cd wechat_web_devtools 3. 自动下载最新 nw.js , 同时部署目录 ~/.config/微信web开发者工具/ ./bin/wxdt install 最好先切换npm淘宝源npm太慢使用淘宝npm镜像&#xA;4. 运行 ./bin/wxdt 7. 错误排除 1. 提示“小程序重启耗时过久，请确认业务逻辑中是否有复杂运算或死循环” 解决方案：apt-get install wine-binfmt</description>
    </item>
    <item>
      <title>windows控制台字体分享</title>
      <link>http://localhost:1313/post/436_windows%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AD%97%E4%BD%93%E5%88%86%E4%BA%AB/</link>
      <pubDate>Fri, 25 Oct 2019 12:59:35 +0000</pubDate>
      <guid>http://localhost:1313/post/436_windows%E6%8E%A7%E5%88%B6%E5%8F%B0%E5%AD%97%E4%BD%93%E5%88%86%E4%BA%AB/</guid>
      <description>为什么有些字体无法设置为控制台字体？ 因为windows对控制台的字体，有着极其严格的要求，只有满足要求的字体才能够被设置。&#xA;windows字体要求 原文已经找不到了，内容如下&#xA;推荐的字体 Microsoft.YaHei.Mono&#xA;microsoft_yahei_mono字体是一款有着高辨识度的微软字体，字形清晰美观可读性强，电脑屏幕显示效果好，看着十分舒服，非常适合编程员使用&#xA;效果预览 参考资料 自定义 Windows PowerShell 和 cmd 的字体&#xA;Microsoft Support: Console (CMD) Fonts</description>
    </item>
    <item>
      <title>axure 9 绘制一个TAB选项卡原型</title>
      <link>http://localhost:1313/post/452_axure-9-%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AAtab%E9%80%89%E9%A1%B9%E5%8D%A1%E5%8E%9F%E5%9E%8B/</link>
      <pubDate>Fri, 25 Oct 2019 12:58:20 +0000</pubDate>
      <guid>http://localhost:1313/post/452_axure-9-%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AAtab%E9%80%89%E9%A1%B9%E5%8D%A1%E5%8E%9F%E5%9E%8B/</guid>
      <description>1. 创建一个Dynamic panel 2. 添加面板状态 双击动态面板，点击state1添加，编辑面板状态&#xA;添加至三个面板状态&#xA;3. 创建选项卡 确保是在对应的state里面添加&#xA;4. 添加选项卡点击事件 为选项卡添加点击切换到对应的state的状态&#xA;依次添加直至所有选项卡都有可切换到对应state的点击事件&#xA;5. 设置响应状态 在不同的state下，设置对应state应该显示的效果&#xA;依次将组件复制到其他state并设置对应显示效果&#xA;6. 预览效果 </description>
    </item>
    <item>
      <title>CSS伪类/伪元素整理笔记</title>
      <link>http://localhost:1313/post/419_css%E4%BC%AA%E7%B1%BB_%E4%BC%AA%E5%85%83%E7%B4%A0%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 16 Oct 2019 10:13:55 +0000</pubDate>
      <guid>http://localhost:1313/post/419_css%E4%BC%AA%E7%B1%BB_%E4%BC%AA%E5%85%83%E7%B4%A0%E6%95%B4%E7%90%86%E7%AC%94%E8%AE%B0/</guid>
      <description>比较官方的解释 伪类 伪类选择元素基于的是当前元素处于的状态，或者说元素当前所具有的特性，而不是元素的id、class、属性等静态的标志。由于状态是动态变化的，所以一个元素达到一个特定状态时，它可能得到一个伪类的样式；当状态改变时，它又会失去这个样式。由此可以看出，它的功能和class有些类似，但它是基于文档之外的抽象，所以叫伪类。&#xA;伪元素 伪元素是对元素中的特定内容进行操作，它所操作的层次比伪类更深了一层，也因此它的动态性比伪类要低得多。实际上，设计伪元素的目的就是去选取诸如元素内容第一个字（母）、第一行，选取某些内容前面或后面这种普通的选择器无法完成的工作。它控制的内容实际上和元素是相同的，但是它本身只是基于元素的抽象，并不存在于文档中，所以叫伪元素。&#xA;一级标题 二级标题 三级标题 四级标题 </description>
    </item>
    <item>
      <title>centos下supervisor的使用笔记</title>
      <link>http://localhost:1313/post/401_centos%E4%B8%8Bsupervisor%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 03 Sep 2019 10:47:19 +0000</pubDate>
      <guid>http://localhost:1313/post/401_centos%E4%B8%8Bsupervisor%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</guid>
      <description>supervisor是一个守护进程工具&#xA;安装 yum install -y supervisor 配置 安装后会生成如下内容&#xA;我们查看一下/etc/supervisord.conf,发现文件最后一行&#xA;这就是在提示我们把配置文件写supervisord.d目录下的ini文件里。&#xA;创建配置文件 首先切换到supervisord.d目录&#xA;touch frps.ini&#xA;nano frps.ini&#xA;复制以下内容(示例为运行frps服务端)&#xA;[program:frps] user=root command=/root/frp/frps/frps -c /root/frp/frps/frps.ini startsecs=1 startretries=100 autorstart=true autorestart=true stderr_logfile=/tmp/err-frps.log stderr_logfile_maxbytes=50MB stderr_logfile_backups=10 stdout_logfile=/tmp/out-frps.log stdout_logfile_maxbytes=50MB stdout_logfile_backups=10 tips supervisorctl status //查看状态 supervisorctl reload //重载配置文件 运行 supervisorctl reload supervisord -c /etc/supervisord.conf 然后再配置好开机自启就OK了</description>
    </item>
    <item>
      <title>pyenv——简单的python版本管理器</title>
      <link>http://localhost:1313/post/96_pyenv__%E7%AE%80%E5%8D%95%E7%9A%84python%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8/</link>
      <pubDate>Tue, 03 Sep 2019 10:27:15 +0000</pubDate>
      <guid>http://localhost:1313/post/96_pyenv__%E7%AE%80%E5%8D%95%E7%9A%84python%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%99%A8/</guid>
      <description>简单的python版本管理器: pyenv pyenv可以让你轻松的在各版本的python环境中切换自如，它是一个简单而又不引人注目并遵循UNIX传统的专用工具。&#xA;这个项目是从rbenv和ruby-buildfork而来, 并且在配合Python的情况下做了适当的修改.&#xA;pyenv能做什么？ 让你在用户基础上改变全局Python版本.&#xA;支持为每一个项目设立一个Python版本.&#xA;允许您使用环境变量覆盖Python版本.&#xA;在多个python环境中搜索命令,这有助于在Python版本中进行测试 tox.&#xA;与pythonbrew和pythonz相比，pyenv不能做什么? 不依赖于Python本身。 pyenv是由纯shell脚本制作的。没有Python的引导问题。&#xA;**不需要加载到你的shell中。**相反，pyenv的shim方法的工作原理是在$ PATH中添加一个目录。&#xA;不能管理virtualenv 当然你可以自行创建virtualenv virtualenv或者使用pyenv-virtualenv去自动化构建&#xA;工作原理 在较高的层次上，pyenv使用shim拦截Python命令注入PATH的可执行文件, 确定哪个Python版本已由您的应用程序指定，并传递您的命令使用你想要的Python安装版本。&#xA;理解PATH(环境变量路径) 当你执行命令,如python或者pip, 你的操作系统会搜索目录列表以查找可执行文件的那个名字.此目录列表位于环境变量中称为PATH, 列表中的每个目录使用用冒号分隔.&#xA;PATH中的目录从左到右搜索，因此首先匹配在列表开头的目录中的可执行文件, 然后一次往右匹配。在这个例子中，首先搜索/usr/local/sbin目录，然后搜索/usr/local/bin，然后是/usr/sbin。&#xA;理解Shims(垫片) pyenv的工作原理是在你的PATH前面插入一个shims目录，这样一来系统在搜索Python的时候第一个找到的就是pyenv管理的Python环境。这个插到最前面的路径就叫做垫片（shims）&#xA;$(pyenv root)/shims:/usr/local/bin:/usr/bin:/bin 通过一个叫做为_rehashing_的进程, pyenv维护shims目录以匹配每个已安装版本的每个Python命令,比如python，pip等。&#xA;垫片是轻量级可执行文件，只是简单地传递命令到pyenv。所以只要安装了pyenv，当你运行时，比如说，pip，你的操作系统将执行以下操作：&#xA;在PATH中搜索名为pip的可执行文件&#xA;在PATH的开头找到名为pip的pyenv垫片&#xA;运行名为pip的垫片，然后将命令传递给属于pyenv的pip命令&#xA;选择Python版本 执行shims程序时，pyenv会确定要使用的Python版本,并按此以下资源顺序读取:&#xA;PYENV_VERSION环境变量（如果指定）. 你可以使用pyenv shell 去设置环境变量在你当前shell session.&#xA;当前特定于应用程序的.python-version文件目录（如果有）. 您可以使用 pyenv local修改当前目录.python-version文件.&#xA;通过搜索每个上层目录,找到第一个.python-version文件（如果有的话），直到到达文件系统的根目录&#xA;全局$(pyenv root)/version文件. 您可以使用pyenv global 修改这个文件. 如果是该全局文件不存在，pyenv假设您要使用“系统”Python。(换句话说，如果pyenv不在您的PATH中，那么任何版本都会运行.)&#xA;NOTE: 您可以同时激活多个版本，甚至包括Python2或Python3的任何版本. 这允许平行使用Python2和Python3，并且需要像tox这样的工具. 例如，要设置你的首次使用的系统Python和Python3的路径（在这个例子中设置为2.7.9和3.4.2），但也可以在你的PATH使用Python 3.3.6,3.2和2.5，首先是pyenv install缺少的版本，然后设置pyenv全局3.3.6 3.2 2.5.这时, 使用pyenv which应该能够找到每个可执行路径, 例如pyenv which python2.5（应该显示$（pyenv root/versions/2.5 /bin/python2.</description>
    </item>
    <item>
      <title>aircrack-ng使用简述</title>
      <link>http://localhost:1313/post/373_aircrack-ng%E4%BD%BF%E7%94%A8%E7%AE%80%E8%BF%B0/</link>
      <pubDate>Fri, 26 Jul 2019 14:31:24 +0000</pubDate>
      <guid>http://localhost:1313/post/373_aircrack-ng%E4%BD%BF%E7%94%A8%E7%AE%80%E8%BF%B0/</guid>
      <description>1. 查看网卡 ifconfig 2. 打开网卡混杂模式 airmon-ng start wlan0 3. 嗅探附近AP airodump-ng wlan0mon 4. 发动deauth攻击使目标重连 aireplay-ng -0 [攻击数量] –a [路由器MAC] -c [客户端MAC] wlan0mon 攻击数量设为0为无限循环模式&#xA;路口器MAC地址为必填项&#xA;客户端MAC，可不填则对路由器所有的客户端进行攻击&#xA;5. 对路由器Dos攻击 sudo mdk3 mon0 a -a D4:83:04:9F:37:28 </description>
    </item>
    <item>
      <title>微信小程序通过uni-app实现v-html渲染视图</title>
      <link>http://localhost:1313/post/314_%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9A%E8%BF%87uni-app%E5%AE%9E%E7%8E%B0v-html%E6%B8%B2%E6%9F%93%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Tue, 02 Jul 2019 11:44:51 +0000</pubDate>
      <guid>http://localhost:1313/post/314_%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%80%9A%E8%BF%87uni-app%E5%AE%9E%E7%8E%B0v-html%E6%B8%B2%E6%9F%93%E8%A7%86%E5%9B%BE/</guid>
      <description>v-html介绍 如果不使用v-html而是直接将html标签加入视图层会出现html标签不解析的情况，如果我们想实现解析的效果。vue中提供了v-html指令。使用 v-html 指令，你可以将html标签解析渲染到视图层。&#xA;微信小程序如何使用？ 由于微信小程序只是类vue的，与vue存在着很多不同点。但是为了秉承将vue进行到底的宗旨，很多微信小程序开发框架如雨后春笋。在我使用的过程中，感觉uni-app与vue最为贴近，而且适配了很多vue的特性，如：v-model，filters，v-html等。官网是这样介绍的。&#xA;其中，他们是通过微信小程序rich-text的属性来实现v-html的效果的。所以，我们想知道支持什么标签，就得移步至rich-text | 微信开发文档&#xA;开始实现Demo demo 中的需求是一个赛事报名list，其中赛事状态有，预报名，报名成功，正在进行，已结束等。&#xA;预实现方法：由于微信小程序的rich-text组件会禁用所有的节点事件，所以想通过@click绑定v-html节点事件，filter渲染界面。但是在实现过程中发现不支持在v-html中使用filter, 故后来采用methods的返回值来实现视图层的渲染。&#xA;效果如下：至此效果，v-html解析成功&#xA;添加状态判断</description>
    </item>
    <item>
      <title>微信小程序开发笔记</title>
      <link>http://localhost:1313/post/209_%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 02 Jul 2019 10:09:35 +0000</pubDate>
      <guid>http://localhost:1313/post/209_%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</guid>
      <description>rpx单位 rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。要实现4:3的展示则可以&#xA;image{ width:750rpx; height:563rpx; } 使用组件库，写的css样式优先级太低 不管三七二十一，加!important&#xA;.findButton { width:300px !important; height:35px !important; } 样式各种飘，不居中怎么办? &amp;lt;view class=&amp;#34;nickName&amp;#34;&amp;gt; &amp;lt;view&amp;gt;{{userInfo.nickName}}&amp;lt;/view&amp;gt; &amp;lt;/view&amp;gt; .nickName { width: 100%; display: flex; align-items: center; justify-content: center; height: 44px; } selectedColor无效 selectedColor 和 list 是同级别的。写在list数组外面就可以了。&#xA;背景虚化 blur中的参数是虚化比例&#xA;filter: blur(1px); scroll-view设置`scroll-x&amp;quot;也不会横向滚动 要给scroll-view加上white-space: nowrap; ，给scroll-view的子元素box加上display:inline-block;</description>
    </item>
    <item>
      <title>Shell入门 </title>
      <link>http://localhost:1313/post/318_shell%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 01 Jul 2019 17:09:24 +0000</pubDate>
      <guid>http://localhost:1313/post/318_shell%E5%85%A5%E9%97%A8/</guid>
      <description>本文诞生原因：作为一个程序员，居然不会shell，说起来也尴尬。&#xA;基本格式 #!/bin/bash ... Shell变量 Shell变量定义不需要关键字，直接定义，不要加$。如name = &amp;quot;hello&amp;quot;&#xA;Shell变量使用的时候需要加$, 花括号为可选项，但是为了让程序可以分清边界，一般使用花括号。如echo ${name}&#xA;只读变量 在前面加readonly&#xA;如：&#xA;#!/bin/bash name=&amp;#34;Hello&amp;#34; readonly name 删除变量 在前面加unset&#xA;变量被删除后不能再次使用。unset 命令不能删除只读变量。&#xA;如：&#xA;#!/bin/sh name=&amp;#34;Hello&amp;#34; unset name shell获取输入 read - 从标准输入读取数值，命令语法：&#xA;read: read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...] 从标准输入中读取一行。 从标准输入中读取一行, 如果提供 -u 则从文件描述符FD中读取一行。该行数据与单词一样分隔, 第一个单词分给第一个变量，第二个分给第二个变量，依次类推，直至最后一个单词. 只有在$IFS中找到的字符才会被识别为单词分隔符。 如果不提供变量，这一行的读取将被存在REPLY变量中。 Options: -a 数组&#x9;将读取的单词分配给顺序数组，下标从零开始。 -d delim&#x9;继续读取直到读取DELIM的第一个字符，而不是换行符. -e&#x9;use Readline to obtain the line in an interactive shell -i text&#x9;use TEXT as the initial text for Readline -n nchars&#x9;return after reading NCHARS characters rather than waiting for a newline, but honor a delimiter if fewer than NCHARS characters are read before the delimiter -N nchars&#x9;return only after reading exactly NCHARS characters, unless EOF is encountered or read times out, ignoring any delimiter -p prompt&#x9;output the string PROMPT without a trailing newline before attempting to read -r&#x9;do not allow backslashes to escape any characters -s&#x9;do not echo input coming from a terminal -t timeout&#x9;time out and return failure if a complete line of input is not read within TIMEOUT seconds.</description>
    </item>
    <item>
      <title>vue事件修饰符（转vue官方文档）</title>
      <link>http://localhost:1313/post/317_vue%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E8%BD%ACvue%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3_/</link>
      <pubDate>Wed, 05 Jun 2019 16:02:38 +0000</pubDate>
      <guid>http://localhost:1313/post/317_vue%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6_%E8%BD%ACvue%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3_/</guid>
      <description>在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。&#xA;为了解决这个问题，Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。&#xA;.stop&#xA;.prevent&#xA;.capture&#xA;.self&#xA;.once&#xA;.passive&#xA;&amp;lt;!-- 阻止单击事件继续传播 --&amp;gt; &amp;lt;a v-on:click.stop=&amp;#34;doThis&amp;#34;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;!-- 提交事件不再重载页面 --&amp;gt; &amp;lt;form v-on:submit.prevent=&amp;#34;onSubmit&amp;#34;&amp;gt;&amp;lt;/form&amp;gt; &amp;lt;!-- 修饰符可以串联 --&amp;gt; &amp;lt;a v-on:click.stop.prevent=&amp;#34;doThat&amp;#34;&amp;gt;&amp;lt;/a&amp;gt; &amp;lt;!-- 只有修饰符 --&amp;gt; &amp;lt;form v-on:submit.prevent&amp;gt;&amp;lt;/form&amp;gt; &amp;lt;!-- 添加事件监听器时使用事件捕获模式 --&amp;gt; &amp;lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&amp;gt; &amp;lt;div v-on:click.capture=&amp;#34;doThis&amp;#34;&amp;gt;...&amp;lt;/div&amp;gt; &amp;lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&amp;gt; &amp;lt;!-- 即事件不是从内部元素触发的 --&amp;gt; &amp;lt;div v-on:click.self=&amp;#34;doThat&amp;#34;&amp;gt;...&amp;lt;/div&amp;gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。&#xA;2.1.4 新增 &amp;lt;!-- 点击事件将只会触发一次 --&amp;gt; &amp;lt;a v-on:click.once=&amp;#34;doThis&amp;#34;&amp;gt;&amp;lt;/a&amp;gt; 不像其它只能对原生的 DOM 事件起作用的修饰符，.once 修饰符还能被用到自定义的组件事件上。如果你还没有阅读关于组件的文档，现在大可不必担心。</description>
    </item>
    <item>
      <title>前端面试贴集锦</title>
      <link>http://localhost:1313/post/315_%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%B4%B4%E9%9B%86%E9%94%A6/</link>
      <pubDate>Wed, 05 Jun 2019 15:51:24 +0000</pubDate>
      <guid>http://localhost:1313/post/315_%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E8%B4%B4%E9%9B%86%E9%94%A6/</guid>
      <description>var obj=/ /; 创建正则对象；若为var obj=/ /； 即赋值被注释掉，及运行被结束；&#xA;只能输入零和非零开头的数字，正确的正则表达式是，^(0|[1-9][0-9]*)$&#xA;有关this的&#xA;this的行为有时候会显得极其诡异，让人感到困惑，但只需要记住 this的值要等到代码真正执行时才能确定&#xA;同时this的值具体有以下几种情况：&#xA;new 调用时指的是被构造的对象&#xA;call、apply调用，指向我们指定的对象&#xA;对象调用，如执行obj.b()，this指向obj&#xA;默认的，指向全局变量window(相当于执行window.fun())</description>
    </item>
    <item>
      <title>uni-app使用v-model</title>
      <link>http://localhost:1313/post/313_uni-app%E4%BD%BF%E7%94%A8v-model/</link>
      <pubDate>Mon, 27 May 2019 16:42:46 +0000</pubDate>
      <guid>http://localhost:1313/post/313_uni-app%E4%BD%BF%E7%94%A8v-model/</guid>
      <description>v-model 介绍 首先明确一点，v-model仅仅是语法糖。&#xA;&amp;lt;input type=&amp;#34;text&amp;#34; v-model=&amp;#34;something&amp;#34;&amp;gt; 等价于&#xA;&amp;lt;input type=&amp;#34;text&amp;#34; v-bind:value=&amp;#34;something&amp;#34; v-on:input=&amp;#34;something = $event.target.value&amp;#34;&amp;gt; 它将一个较复杂的input双向数据绑定简化了他的书写方式。&#xA;微信小程序绑定input 最开始我是使用微信推荐的写法&#xA;&amp;lt;input bindtap=&amp;#34;input&amp;#34; /&amp;gt; 然后在js里面解析event，然后再setData&#xA;uni-app下v-model的写法 本文采用uni-app自定义组件模式&#xA;wxml&#xA;... &amp;lt;form @submit=&amp;#34;formSubmit&amp;#34; @reset=&amp;#34;formReset&amp;#34; :model=&amp;#34;formItem&amp;#34; class=&amp;#34;tm-every-center padding bg-white&amp;#34;&amp;gt; &amp;lt;view class=&amp;#34;section flex align-center&amp;#34;&amp;gt; &amp;lt;view class=&amp;#34;section__title&amp;#34;&amp;gt;姓名：&amp;lt;/view&amp;gt; &amp;lt;input name=&amp;#34;name&amp;#34; placeholder=&amp;#34;请填写您的姓名&amp;#34; class=&amp;#34;bg-gray&amp;#34; v-model=&amp;#34;formItem.name&amp;#34; /&amp;gt; &amp;lt;/view&amp;gt; &amp;lt;view class=&amp;#34;section flex align-center&amp;#34;&amp;gt; &amp;lt;view class=&amp;#34;section__title&amp;#34;&amp;gt;手机：&amp;lt;/view&amp;gt; &amp;lt;input name=&amp;#34;name&amp;#34; placeholder=&amp;#34;请填写您的姓名&amp;#34; class=&amp;#34;bg-gray&amp;#34; v-model=&amp;#34;formItem.phone&amp;#34; /&amp;gt; &amp;lt;/view&amp;gt; &amp;lt;view class=&amp;#34;section flex align-center&amp;#34;&amp;gt; &amp;lt;view class=&amp;#34;section__title&amp;#34;&amp;gt;赛点：&amp;lt;/view&amp;gt; &amp;lt;input name=&amp;#34;name&amp;#34; placeholder=&amp;#34;请填写您的姓名&amp;#34; class=&amp;#34;bg-gray&amp;#34; v-model=&amp;#34;formItem.competition&amp;#34; /&amp;gt; &amp;lt;/view&amp;gt; &amp;lt;view class=&amp;#34;btn-area margin-top&amp;#34;&amp;gt;&amp;lt;button formType=&amp;#34;submit&amp;#34; class=&amp;#34;cu-btn&amp;#34;&amp;gt;提交&amp;lt;/button&amp;gt;&amp;lt;/view&amp;gt; &amp;lt;/form&amp;gt; .</description>
    </item>
    <item>
      <title>文本编辑器技巧之正则匹配操作</title>
      <link>http://localhost:1313/post/207_%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 24 Apr 2019 22:15:28 +0000</pubDate>
      <guid>http://localhost:1313/post/207_%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%E6%93%8D%E4%BD%9C/</guid>
      <description>正则删除关键字所在行 查找：&#xA;^.*大师兄.*$ 替换为：（空） 如果不留空行：&#xA;查找：&#xA;^.*大师兄.*\r?\n 替换为：（空）&#xA;正则删除HTML标签 Ctrl + H 正则匹配 &amp;lt;[^&amp;gt;]+&amp;gt; 替换为空&#xA;正则替换换行 Ctrl + H 正则匹配 \n 替换为你想要的</description>
    </item>
    <item>
      <title>使用console的一些骚操作来封装API请求及输出相关日志</title>
      <link>http://localhost:1313/post/297_%E4%BD%BF%E7%94%A8console%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AA%9A%E6%93%8D%E4%BD%9C%E6%9D%A5%E5%B0%81%E8%A3%85api%E8%AF%B7%E6%B1%82%E5%8F%8A%E8%BE%93%E5%87%BA%E7%9B%B8%E5%85%B3%E6%97%A5%E5%BF%97/</link>
      <pubDate>Tue, 02 Apr 2019 11:39:22 +0000</pubDate>
      <guid>http://localhost:1313/post/297_%E4%BD%BF%E7%94%A8console%E7%9A%84%E4%B8%80%E4%BA%9B%E9%AA%9A%E6%93%8D%E4%BD%9C%E6%9D%A5%E5%B0%81%E8%A3%85api%E8%AF%B7%E6%B1%82%E5%8F%8A%E8%BE%93%E5%87%BA%E7%9B%B8%E5%85%B3%E6%97%A5%E5%BF%97/</guid>
      <description>最终效果如下 代码如下 const baseURL = &amp;#39;http://wxlc.wezoz.com/&amp;#39; // your base url async function request(api, method, header, params) { console.group(api) console.log(&amp;#39;%c&amp;#39; + method + &amp;#39; REQUEST:&amp;#39;, &amp;#34;color:green&amp;#34;) console.log({ &amp;#39;api&amp;#39;: api, &amp;#39;header&amp;#39;: header, &amp;#39;params&amp;#39;: params }) return await new Promise((resolve, reject) =&amp;gt; { uni.request({ url: baseURL + api, method: method, header: header, data: params, success: (result) =&amp;gt; { console.log(&amp;#39;%c&amp;#39; + method + &amp;#39; SUCCESS RETURN DATA:&amp;#39;, &amp;#34;color:green&amp;#34;) console.log(result) console.groupEnd(api) resolve(result.data); }, fail: (e) =&amp;gt; { reject(e); } }) }) } async function post(api, params, success) { const POST_METHOD = &amp;#39;POST&amp;#39; const POST_HEADER = { &amp;#39;content-type&amp;#39;: &amp;#39;application/x-www-form-urlencoded&amp;#39;, &amp;#39;token&amp;#39;: wx.</description>
    </item>
    <item>
      <title>win10下使用wsl配置Clion toolchain</title>
      <link>http://localhost:1313/post/275_win10%E4%B8%8B%E4%BD%BF%E7%94%A8wsl%E9%85%8D%E7%BD%AEclion-toolchain/</link>
      <pubDate>Thu, 28 Mar 2019 13:16:13 +0000</pubDate>
      <guid>http://localhost:1313/post/275_win10%E4%B8%8B%E4%BD%BF%E7%94%A8wsl%E9%85%8D%E7%BD%AEclion-toolchain/</guid>
      <description>前言 为什么要使用wsl来配置呢？因为我个人感觉这个比较方便，不用安装一堆包。直接敲命令就好。&#xA;准备工作 安装好Clion后，打开toolchain是这样的。&#xA;前提是先装好wsl&#xA;选择wsl toolchain 会出现下面这个情况&#xA;这是因为wsl没有配置ssh服务&#xA;配置wsl的ssh sudo vi /etc/ssh/sshd_config 把密码认证的no改为yes&#xA;PasswordAuthentication yes restart ssh sudo service ssh restart 如果出现以下提示&#xA;则需要生成key&#xA;sudo dpkg-reconfigure openssh-server 查看ssh运行状态 service ssh status configure remote credentials 配置编译环境 在wsl里面执行&#xA;sudo apt-get install build-essential gcc g++ cmake gdb </description>
    </item>
    <item>
      <title>毕业设计对象类篇(一)交通灯类之路口状态</title>
      <link>http://localhost:1313/post/197_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%AF%B9%E8%B1%A1%E7%B1%BB%E7%AF%87_%E4%B8%80_%E4%BA%A4%E9%80%9A%E7%81%AF%E7%B1%BB%E4%B9%8B%E8%B7%AF%E5%8F%A3%E7%8A%B6%E6%80%81/</link>
      <pubDate>Fri, 22 Mar 2019 10:59:43 +0000</pubDate>
      <guid>http://localhost:1313/post/197_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E5%AF%B9%E8%B1%A1%E7%B1%BB%E7%AF%87_%E4%B8%80_%E4%BA%A4%E9%80%9A%E7%81%AF%E7%B1%BB%E4%B9%8B%E8%B7%AF%E5%8F%A3%E7%8A%B6%E6%80%81/</guid>
      <description>所有的路口标号用int road[8]表示，&#xA;用bool status[8][8]表示道路可否通行。&#xA;T字路口 对于T字路口，将道路分为（左，右，下）三个流量出入口，存在的状态有：&#xA;0. 全红(特殊状态应对突发事故） for (int i = 0; i &amp;lt; 8; i++) { for (int j = 0; j &amp;lt; 8; j++) { status[i][j] = false; } } ×|0|1|2|3|4|5&#xA;:&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: |&#xA;0|×|×|×|×|×|×&#xA;1|×|×|×|×|×|×&#xA;2|×|×|×|×|×|×&#xA;3|×|×|×|×|×|×&#xA;4|×|×|×|×|×|×&#xA;5|×|×|×|×|×|×&#xA;正常状态下考虑红灯可右转，同向变道不受交通灯控制，即永远可通行&#xA;status[2][1] = status[4][3] = true; status[0][1] = status[2][3] = status[4][5] = true; ×|0|1|2|3|4|5&#xA;:&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: | :&amp;ndash;: |</description>
    </item>
    <item>
      <title>毕业设计番外篇(一)之车辆路径的计算</title>
      <link>http://localhost:1313/post/153_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%95%AA%E5%A4%96%E7%AF%87_%E4%B8%80_%E4%B9%8B%E8%BD%A6%E8%BE%86%E8%B7%AF%E5%BE%84%E7%9A%84%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Thu, 21 Mar 2019 15:38:04 +0000</pubDate>
      <guid>http://localhost:1313/post/153_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E7%95%AA%E5%A4%96%E7%AF%87_%E4%B8%80_%E4%B9%8B%E8%BD%A6%E8%BE%86%E8%B7%AF%E5%BE%84%E7%9A%84%E8%AE%A1%E7%AE%97/</guid>
      <description>目前，我采用的是迪杰斯特拉算法计算所有点的最短路径（感觉弗洛伊德算法会更好些？）。迪杰斯特拉算法算的是单源（V_begin)到所有点的最短距离，也就是说需要遍历一次所有的点。&#xA;遍历V_begin for (int V_begin = 0; V_begin &amp;lt; G-&amp;gt;m_CrossRoad_v.size(); V_begin++) { } 下面是迪杰斯特拉算法的流程&#xA;1. 声明dist数组 vector&amp;lt;double&amp;gt; Determined_dist(G-&amp;gt;m_CrossRoad_v.size(), 0.0); 2. 初始化顶点集 void calcShortestPath(Graph *G) { int currentPointSite,nextPointSite; ofstream PointPathFile(DIR_RES&amp;#34;PointPath.txt&amp;#34;),RoadPathFile(DIR_RES&amp;#34;RoadPath.txt&amp;#34;); //对点进行的一级遍历 for (int V_begin = 0; V_begin &amp;lt; G-&amp;gt;m_CrossRoad_v.size(); V_begin++) { // =================== 迪杰斯特拉算法开始 =============================== vector&amp;lt;bool&amp;gt; S(G-&amp;gt;m_CrossRoad_v.size(), false); //判断是否选中 vector&amp;lt;double&amp;gt; dist(G-&amp;gt;m_CrossRoad_v.size(), DBL_MAX/2);// dist vector&amp;lt;double&amp;gt; compare_dist(G-&amp;gt;m_CrossRoad_v.size(), DBL_MAX/2);// 辅助dist用来取最短距离点 vector&amp;lt;int&amp;gt; path(G-&amp;gt;m_CrossRoad_v.size(),-2); // path S[V_begin] = true; path[V_begin] = -1; for(auto crossroad : G-&amp;gt;m_CrossRoad_v[V_begin].</description>
    </item>
    <item>
      <title>javascript的一些笔记</title>
      <link>http://localhost:1313/post/247_javascript%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 13 Mar 2019 14:51:30 +0000</pubDate>
      <guid>http://localhost:1313/post/247_javascript%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/</guid>
      <description>js类似于printf那样的格式化字符串 安装包&#xA;npm install sprintf-js 调用包&#xA;var sprintf = require(&amp;#39;sprintf-js&amp;#39;).sprintf, 操作实例：时间前补零操作&#xA;for (let i = 46; i &amp;gt;= 0; i--) { console.log(sprintf(&amp;#39;%2d:%02d&amp;#39;, i / 2, (i % 2 ? 0 : 30))) } </description>
    </item>
    <item>
      <title>nodejs的一些笔记</title>
      <link>http://localhost:1313/post/208_nodejs%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 12 Mar 2019 16:20:43 +0000</pubDate>
      <guid>http://localhost:1313/post/208_nodejs%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/</guid>
      <description>安装nodejs sudo apt-get install nodejs sudo apt-get install npm 全局安装包 sudo npm i -g cnpm 查看全局安装的包 npm list -g --depth 0 全局卸载包 sudo npm uninstall -g cnpm 清理缓存 npm cache clean -f 默认镜像太慢换淘宝镜像 npm config set registry https://registry.npm.taobao.org 现在我常使用cnpm包&#xA;检查配置是否成功&#xA;npm config get registry </description>
    </item>
    <item>
      <title>毕业设计思路篇(一)之交通图的构建</title>
      <link>http://localhost:1313/post/70_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E7%AF%87_%E4%B8%80_%E4%B9%8B%E4%BA%A4%E9%80%9A%E5%9B%BE%E7%9A%84%E6%9E%84%E5%BB%BA/</link>
      <pubDate>Sun, 17 Feb 2019 23:22:33 +0000</pubDate>
      <guid>http://localhost:1313/post/70_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E7%AF%87_%E4%B8%80_%E4%B9%8B%E4%BA%A4%E9%80%9A%E5%9B%BE%E7%9A%84%E6%9E%84%E5%BB%BA/</guid>
      <description>1. 导入道路地图 道路地图来自网络数据,已预处理为xml格式。&#xA;&amp;lt;?xml version=&amp;#39;1.0&amp;#39; encoding=&amp;#39;UTF-8&amp;#39;?&amp;gt; &amp;lt;Roads&amp;gt; &amp;lt;road m_ID=&amp;#34;71283896--1&amp;#34; len=&amp;#34;620.98&amp;#34;&amp;gt; &amp;lt;from lon=&amp;#34;113.9205606&amp;#34; lat=&amp;#34;22.9317667&amp;#34; id=&amp;#34;848388981&amp;#34;/&amp;gt; &amp;lt;to lon=&amp;#34;113.9260573&amp;#34; lat=&amp;#34;22.9341232&amp;#34; id=&amp;#34;2522072722&amp;#34;/&amp;gt; &amp;lt;/road&amp;gt; &amp;lt;road m_ID=&amp;#34;553852656--2&amp;#34; len=&amp;#34;322.34&amp;#34;&amp;gt; &amp;lt;from lon=&amp;#34;113.9529339&amp;#34; lat=&amp;#34;22.9448978&amp;#34; id=&amp;#34;5345735265&amp;#34;/&amp;gt; &amp;lt;to lon=&amp;#34;113.9516926&amp;#34; lat=&amp;#34;22.9475618&amp;#34; id=&amp;#34;5345735267&amp;#34;/&amp;gt; &amp;lt;/road&amp;gt; &amp;lt;/Roads&amp;gt; 解析：一个road节点代表一条道路，len代表道路抽象长度，from，to子节点分别表示道路两端端点。&#xA;2. 解析道路数据 a. 构建交通图 赋值道路端点.&#xA;/** * 路口类，记录着该路口的点坐标，以及其相连的方向道路节点组 * | | * | | | * | 1 2 | * | | | * -------- -------- * 3 5 * - - - - - - - - * 4 6 * -------- -------- * | | | * | 7 8 | * | | | * | | * 如上图(1,2), (3,4), (5,6), (7,8)在同一个方向,我将其称为四组方向道路节点Node.</description>
    </item>
    <item>
      <title>毕业设计思路篇(四)之生成车辆</title>
      <link>http://localhost:1313/post/140_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E7%AF%87_%E5%9B%9B_%E4%B9%8B%E7%94%9F%E6%88%90%E8%BD%A6%E8%BE%86/</link>
      <pubDate>Sun, 17 Feb 2019 15:38:47 +0000</pubDate>
      <guid>http://localhost:1313/post/140_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E7%AF%87_%E5%9B%9B_%E4%B9%8B%E7%94%9F%E6%88%90%E8%BD%A6%E8%BE%86/</guid>
      <description> generateVehicle(Map_Graph); 1. 随机车辆总数 此处未随机，待完善 std::random_device rd; std::mt19937 mt(rd()); 2. 遍历车辆，为车辆设立起点和路线 a. 在道路向量中随机选一条路径 -[ ] 此处未随机，待完善&#xA;auto route = v_Route[3]; b. 以该路径的首序列为起点 Vehicle car(n_VehicleNum, route, 0, 0, route.front()); G.m_Road_v[route.front()].m_queVehicle.push_back(car); </description>
    </item>
    <item>
      <title>codeigniter的一些笔记</title>
      <link>http://localhost:1313/post/159_codeigniter%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 16 Feb 2019 22:32:43 +0000</pubDate>
      <guid>http://localhost:1313/post/159_codeigniter%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/</guid>
      <description>title: codeigniter | codeigniter的一些笔记&#xA;tags: codeigniter&#xA;categories: 笔记&#xA;abbrlink: 15d8&#xA;date: 2018-04-02 13:15:42&#xA;thumbnail:&#xA;codeigniter 部署坑 session 文件路径问题 解决方法 在application/config/config.php 中最后一行, 加入&#xA;$config[&amp;#39;sess_save_path&amp;#39;] =BASEPATH.&amp;#39;../&amp;#39;.&amp;#39;session_file&amp;#39;; 原因 未设置ssesion文件路径,会默认使用php.ini的文件路径,可能会出现无路径访问权限的问题&#xA;baseurl 修改 要记得修改baseurl的值,以免出现访问不成功的情况&#xA;$config[&amp;#39;base_url&amp;#39;] = &amp;#39;https://www.farminbackyard.com&amp;#39;; pasue;</description>
    </item>
    <item>
      <title>Deepin下Clion的相关问题</title>
      <link>http://localhost:1313/post/158_deepin%E4%B8%8Bclion%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</link>
      <pubDate>Sat, 16 Feb 2019 22:31:19 +0000</pubDate>
      <guid>http://localhost:1313/post/158_deepin%E4%B8%8Bclion%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</guid>
      <description> layout: post&#xA;title: Deepin下Clion的相关问题&#xA;tags:&#xA;C++ categories:&#xA;笔记 abbrlink: dd6c&#xA;date: 2018-09-10 08:33:30&#xA;此文记录Deepin下Clion的相关问题&#xA;toolchain不完整 sudo apt-get install build-essential 待续 </description>
    </item>
    <item>
      <title>Bootstrap-table 爬坑之旅</title>
      <link>http://localhost:1313/post/157_bootstrap-table-%E7%88%AC%E5%9D%91%E4%B9%8B%E6%97%85/</link>
      <pubDate>Sat, 16 Feb 2019 22:29:38 +0000</pubDate>
      <guid>http://localhost:1313/post/157_bootstrap-table-%E7%88%AC%E5%9D%91%E4%B9%8B%E6%97%85/</guid>
      <description>继上次被坑后,由于未做笔记, 没想的我再次败在这个坑上, 自我感觉我还将使用bootstraap-table一段时间, 所以为了避免下次再被这个坑坑一个下午的时间. 我决定将它记录下来.&#xA;首先, 前端table插件有很多, 但是由于它是我接触的第一个,所以可能会用它一定的时间.&#xA;我采用的是, data-url,数据与视图分离的格式.&#xA;坑:&#xA;在operation的formatter和events的设定时, 切记不要设置data-field的值,否则会出现events显示不了的情况 . 在引入js拓展时,注意后面的js不能与其冲突,导致改变引入顺序 </description>
    </item>
    <item>
      <title>毕业设计汇总篇</title>
      <link>http://localhost:1313/post/113_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB%E7%AF%87/</link>
      <pubDate>Tue, 12 Feb 2019 20:45:28 +0000</pubDate>
      <guid>http://localhost:1313/post/113_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%B1%87%E6%80%BB%E7%AF%87/</guid>
      <description>&#xA;思路篇 思路篇主要记录程序流程思路&#xA;毕业设计思路篇(一)之道路数据的抽象 毕业设计思路篇(二)之交通灯的初始化 毕业设计思路篇(三)之预加载车辆路线 毕业设计思路篇(四)之生成车辆 毕业设计思路篇(五)之交通流量模拟 番外篇 番外篇主要记录非主要流程（即并非每次运行都会执行的模块，比如预处理等）。每个模块可单独修改或维护，而不影响主流程。&#xA;毕业设计番外篇(一)之车辆路径的构建 </description>
    </item>
    <item>
      <title>毕业设计思路篇(五)之交通流量模拟</title>
      <link>http://localhost:1313/post/145_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E7%AF%87_%E4%BA%94_%E4%B9%8B%E4%BA%A4%E9%80%9A%E6%B5%81%E9%87%8F%E6%A8%A1%E6%8B%9F/</link>
      <pubDate>Mon, 11 Feb 2019 22:11:44 +0000</pubDate>
      <guid>http://localhost:1313/post/145_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E7%AF%87_%E4%BA%94_%E4%B9%8B%E4%BA%A4%E9%80%9A%E6%B5%81%E9%87%8F%E6%A8%A1%E6%8B%9F/</guid>
      <description>runSimulation(Graph &amp;amp;G) 1. 遍历每条道路 2. 遍历该道路的车辆 a. 计算特定时间间隔后的位置 b. 若应行驶至其他道路 进入对应的路口缓冲区，根据路口类的红绿灯对象判断是否能通行。&#xA;若能通行，则填至目标道路&#xA;若不能，则继续停留在路口缓冲区&#xA;c. 若仍停留在原道路 改变该车在当前道路的位置。&#xA;for (auto &amp;amp;road:G.m_Road_v) { auto src = road.m_queVehicle; decltype(road.m_queVehicle) obj; //路内车的遍历 while (!src.empty()) { //弹出一辆车 auto it = src.front(); src.pop_front(); // 当车的时间戳小于实际时间时，才模拟运行 if (it.time &amp;lt; SYSTEM_TIME) { it.fSpec = (100 - road.get_Congestion() - 20) / 3.6; dist = it.dDistance + it.fSpec * 10; it.time++; it.showself(); //如果车十秒后不在此路 if (dist &amp;gt;= road.m_dLength) { //路径擦除 auto route = it.</description>
    </item>
    <item>
      <title>毕业设计思路篇(三)之预加载车辆路线</title>
      <link>http://localhost:1313/post/129_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E7%AF%87_%E4%B8%89_%E4%B9%8B%E9%A2%84%E5%8A%A0%E8%BD%BD%E8%BD%A6%E8%BE%86%E8%B7%AF%E7%BA%BF/</link>
      <pubDate>Sat, 09 Feb 2019 18:47:51 +0000</pubDate>
      <guid>http://localhost:1313/post/129_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E7%AF%87_%E4%B8%89_%E4%B9%8B%E9%A2%84%E5%8A%A0%E8%BD%BD%E8%BD%A6%E8%BE%86%E8%B7%AF%E7%BA%BF/</guid>
      <description>1. 从文件(route.txt)中读取路径 形如以下格式&#xA;0 1 0 1 2 0 1 2 3 0 1 2 3 4 0 1 2 3 4 5 0 1 2 3 4 5 6 0 1 2 3 4 5 6 7 其中，一行表示一条可完全畅通的道路编号序列。将所有道路存入v_Route&#xA;vector&amp;lt;queue&amp;lt;int&amp;gt;&amp;gt; v_Route; /** * load route from route file * @param Map_graph */ void loadRoute(Graph &amp;amp;Map_graph) { string str_Path; ifstream fin_Route(DIR_RES&amp;#34;route.txt&amp;#34;); while (getline(fin_Route, str_Path)) { stringstream ss_Temp(str_Path); queue&amp;lt;int&amp;gt; q_Path_Temp; int n_Temp; while (ss_Temp &amp;gt;&amp;gt; n_Temp) { q_Path_Temp.</description>
    </item>
    <item>
      <title>毕业设计思路篇(二)之交通灯的初始化</title>
      <link>http://localhost:1313/post/121_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E7%AF%87_%E4%BA%8C_%E4%B9%8B%E4%BA%A4%E9%80%9A%E7%81%AF%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Sat, 26 Jan 2019 17:36:41 +0000</pubDate>
      <guid>http://localhost:1313/post/121_%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E7%AF%87_%E4%BA%8C_%E4%B9%8B%E4%BA%A4%E9%80%9A%E7%81%AF%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>道路类型的设置 it-&amp;gt;m_CTrafficLight_Light.setType(it-&amp;gt;JunctionRoad.size()); 根据路口道路条数, 设置路灯类型(是T字路口还是+字路口)&#xA;/** * 交通灯类 */ class TrafficLight { public: TrafficLight() { for (int i = 0; i &amp;lt; 8; i++) { roadID[i] = -1; } }; void changeStatus(); void clock(int time); void setAllRed(); void setAllGreen(); bool getStatus(int from, int to); /** * 设置灯的类型, 是T字路口还是+字路口 * @param type */ void setType(int type) { this-&amp;gt;type = type; }; //路口标号 // nLeftIn,nLeftOut,nDownIn,nDownOut,nRightIn,nRightOut,nUpIn,nUpOut; int roadID[8]; //路口是否能走通 bool status[4][4] = {false}; int type; //表示可通过的方向（目标方向） //AllRED = 0,LeftGreen = 1,DownGreen = 2,RightGreen = 3,UpGreen = 4,UpDownGreen = 5,LeftRightGreen = 6,cross1 = 7,cross2 = 8 int emStatus = 0; long long int time = 0; }; 对接各路口</description>
    </item>
    <item>
      <title>微信小程序svg转canvas</title>
      <link>http://localhost:1313/post/123_%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fsvg%E8%BD%ACcanvas/</link>
      <pubDate>Mon, 21 Jan 2019 22:07:52 +0000</pubDate>
      <guid>http://localhost:1313/post/123_%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fsvg%E8%BD%ACcanvas/</guid>
      <description>首先，为什么我们需要这个？&#xA;因为微信小程序虽然可以可以绘制svg图片，但是在真机调试的时候却渲染不出来。所以我们需要一个工具(可以将svg转成微信小程序支持的canvas并绘制出来)。&#xA;我使用的是touch-wx + vs code 开发。&#xA;现已启用该开发模式.因为Ubuntu下经常编译不完整&#xA;Touch WX 是什么？ Touch WX是一套完全免费的微信小程序开发框架，包含丰富的UI控件用于官方组件的补充。与Touch UI开发方式很相似，也是通过VSCode编辑器+插件的方式开发，经过编译后输出小程序代码。&#xA;与其他小程序框架最主要的区别在于：Touch UI完全是基于小程序官方的自定义组件机制实现，输出的是小程序原始代码，而不是输出开发者完全无法阅读的编译代码。这样当遇到问题时，开发者可以很方便的定位问题所在，还可以基于输出的原始代码继续开发。&#xA;当你用Touch UI开发了H5应用，可以直接导入到Touch WX进行转换，稍作调整就能生成小程序。反之也同样，当你Touch WX开发了微信小程序，可以导出为Touch UI工程来生成H5应用。&#xA;Touch WX 的特点 我的理解 Touch WX 就是一个可以将特定的nodejs项目编译成微信小程序项目的框架&#xA;Touch WX更多操作 更多操作见http://www.touchui.io/touchui_doc_wx/&#xA;推荐大家看一下，或许会打开新世界的大门哦！&#xA;接下来，我默认你已经看了Touch WX的文档，并且拥有一定的nodejs基础&#xA;开始流程 安装parse-svg-path npm install parse-svg-path --save&#xA;引入parse-svg-path var parse = require(&#39;parse-svg-path&#39;)&#xA;使用parse-svg-path parse(d)&#xA;d为svg中的path值&#xA;不了解svg？&#xA;请转http://www.w3school.com.cn/svg/svg_intro.asp&#xA;如何获得path值？ var options = { url:&amp;#34;svg的URL&amp;#34;, success:function(res){ const ctx = wx.createCanvasContext(&amp;#39;myCanvas&amp;#39;) ctx.setFillStyle(&amp;#39;black&amp;#39;) var match = res.data.match(/d=&amp;#34;(.*?)&amp;#34;/); var d = match[1]; console.</description>
    </item>
    <item>
      <title>python3 &#43; Django &#43; uwsgi &#43; nginx 配置部署笔记</title>
      <link>http://localhost:1313/post/11_python3-_-django-_-uwsgi-_-nginx-%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 16 Jan 2019 11:13:56 +0000</pubDate>
      <guid>http://localhost:1313/post/11_python3-_-django-_-uwsgi-_-nginx-%E9%85%8D%E7%BD%AE%E9%83%A8%E7%BD%B2%E7%AC%94%E8%AE%B0/</guid>
      <description>本文环境&#xA;操作系统: Ubuntu 16.04.3&#xA;Python版本: 3.5.2&#xA;Django版本: 2.0.4&#xA;nginx版本: 1.10.3&#xA;本文平台为腾讯云1核1G系统&#xA;我的项目文件名为: dgutpsy&#xA;安装pip3(python3 的pip) sudo apt-get install python3-pip 安装成功后运行pip3将会出现&#xA;安装uwsgi pip install uwsgi 测试uwsgi运行状态 新建文件test.py&#xA;def application(env, start_response): start_response(&amp;#39;200 OK&amp;#39;, [(&amp;#39;Content-Type&amp;#39;,&amp;#39;text/html&amp;#39;)]) return [b&amp;#34;Hello World&amp;#34;] 有些教程说是 return &amp;quot;hello world&amp;quot;&#xA;但是这样其实会出现访问空白的情况, 我的是Python3的环境，需要对hello world进行编码.&#xA;而如果你是Python2的环境，你应该写return &amp;quot;hello world&amp;quot;&#xA;使用uwsgi运行该文件 uwsgi --http :8000 --wsgi-file test.py 此语句的意思是，使用uwsgi运行test.py文件， 采用http模式， 端口8000&#xA;访问页面 好啦,可以看到亲切的hello world 就说明uwsgi运行成功了&#xA;TIPS: 如果你访问不了,请先检查腾讯云安全组端口是否开放8000端口&#xA;安装Django pip3 install Django 如在python3里面import django没有报错则安装成功.&#xA;上传项目代码 现在我们开始上传项目代码&#xA;使用MobaXterm的sftp工具拖进来,[笑着哭]不要问我为什么不用ftp,这个方便.</description>
    </item>
    <item>
      <title>C&#43;&#43;11新特性之auto的妙用</title>
      <link>http://localhost:1313/post/77_c__11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bauto%E7%9A%84%E5%A6%99%E7%94%A8/</link>
      <pubDate>Wed, 16 Jan 2019 11:12:41 +0000</pubDate>
      <guid>http://localhost:1313/post/77_c__11%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8Bauto%E7%9A%84%E5%A6%99%E7%94%A8/</guid>
      <description>C++11引入了auto和decltype关键字实现类型推导，通过这两个关键字不仅能方便地获得复杂的类型，还能简化书写，提高编码效率。下面说一下C++中的auto&#xA;旧标准 auto其实并不是一个新的关键字，在旧的标准C++98/03中，它代表着“具有自动存储周期的局部变量”。啥意思呢？就是我们平常所说的变量，他与static相对。就是说所有非static类型的都是“具有自动存储期的”。也就是说在旧的标准下。&#xA;autoint i =3;//等价于int i=3; 新标准 在C++11中，auto作为一个新的类型指示符（如int，double）来指示编译器的，但是auto申明的变量的类型必须由编译器在编译时期推导出来，也称类型推导。这种类型推导不是C++所独有的，还有很多具备这种能力的语言（如Python，Javascript）。我们先来看一段Python代码&#xA;name =&amp;#34;thinkmoon&amp;#34;print&amp;#34;hello,&amp;#34;+ name 在这里的name是不需要定义类型的，因为这个类型很容易被推导为字符串性，如过要想在C++中实现这种效果，我们可以这样。&#xA;#include&amp;lt;iostream&amp;gt; int main(){ auto name =&amp;#34;thinkmoon&amp;#34;; std::cout &amp;lt;&amp;lt;&amp;#34;hello,&amp;#34;&amp;lt;&amp;lt; name &amp;lt;&amp;lt; std::endl; return0; } 效果是一样的，是不是觉得写起来特别的方便呢？&#xA;但是需要注意的是，在C++中这种静态类型推导是发生在编译期间的。而像Python这种动态类型推导却是发生在运行期间的。&#xA;auto的基本用法 #include&amp;lt;iostream&amp;gt; usingnamespace std; int main(){ auto x =5; cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl;//x被推导为intauto p =newauto(1); cout &amp;lt;&amp;lt;&amp;#34;*&amp;#34;&amp;lt;&amp;lt; p &amp;lt;&amp;lt;&amp;#34;=&amp;#34;&amp;lt;&amp;lt;*p &amp;lt;&amp;lt; endl;//p被推导为 int *constauto*v =&amp;amp;x, u =6; cout &amp;lt;&amp;lt;&amp;#34;*&amp;#34;&amp;lt;&amp;lt; v &amp;lt;&amp;lt;&amp;#34;=&amp;#34;&amp;lt;&amp;lt;*v &amp;lt;&amp;lt;&amp;#34;\n u=&amp;#34;&amp;lt;&amp;lt; u &amp;lt;&amp;lt; endl;//v被推导为const int *，u被推导const int } 对于最后一个类型推导有几个需要注意</description>
    </item>
    <item>
      <title>node环境安装canvas写中文并自定义字体生成图片</title>
      <link>http://localhost:1313/post/24_node%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85canvas%E5%86%99%E4%B8%AD%E6%96%87%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87/</link>
      <pubDate>Wed, 16 Jan 2019 11:09:30 +0000</pubDate>
      <guid>http://localhost:1313/post/24_node%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85canvas%E5%86%99%E4%B8%AD%E6%96%87%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87/</guid>
      <description>为什么要在服务端装canvas？ 因为并不是所有的客户端都能很好的支持canvas（比如微信小程序不能修改自定义字体），所以我们需要一个&#xA;能够在服务端生成图片的，然后将图片传输&#xA;安装node-canvas 1. 更新编译环境 sudo apt-get install libcairo2-dev libjpeg8-dev libpango1.0-dev libgif-dev build-essential g++ -y 2. 安装node-canvas npm install -g canvas 3. 测试代码 var Canvas = require(&amp;#39;canvas&amp;#39;), canvas = new Canvas(300, 200), ctx = canvas.getContext(&amp;#39;2d&amp;#39;), fs = require(&amp;#39;fs&amp;#39;); var out = fs.createWriteStream(__dirname + &amp;#39;/image.png&amp;#39;) , stream = canvas.createPNGStream(); stream.on(&amp;#39;data&amp;#39;, function(chunk){ out.write(chunk); }); //在左边画正方形 ctx.fillStyle = &amp;#39;#A00&amp;#39; ctx.fillRect(0, 30,50,50); //在右边画正方形 ctx.fillStyle = &amp;#39;#aaa&amp;#39; ctx.fillRect(50, 30, 50, 50); //画文字 ctx.fillStyle = &amp;#34;#000&amp;#34;; ctx.</description>
    </item>
    <item>
      <title>微信公众平台开发笔记</title>
      <link>http://localhost:1313/post/20_%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 16 Jan 2019 11:08:10 +0000</pubDate>
      <guid>http://localhost:1313/post/20_%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/</guid>
      <description>URL跳转, 链接跳转&#xA;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&amp;quot;.$this-&amp;gt;appid.&amp;quot;&amp;amp;redirect_uri=&amp;quot;.urlencode(&amp;quot;http://192.168.43.46/auit/index.php?c=app&amp;amp;m=oauth&amp;quot;).&amp;quot;&amp;amp;response_type=code&amp;amp;scope=snsapi_userinfo&amp;amp;state=STATE#wechat_redirect&#xA;用户进入页面,拿code换取ACCESS_TOKEN, 请求代码 file_get_contents(&amp;#34;https://api.weixin.qq.com/sns/oauth2/access_token?appid=&amp;#34;.$this-&amp;gt;appid.&amp;#34;&amp;amp;secret=&amp;#34;.$this-&amp;gt;secret.&amp;#34;&amp;amp;code=&amp;#34;.$_GET[&amp;#39;code&amp;#39;].&amp;#34;&amp;amp;grant_type=authorization_code&amp;#34;); 用ACCESS_TOKEN换取用户数据,请求代码 file_get_contents(&amp;#34;https://api.weixin.qq.com/sns/userinfo?access_token=&amp;#34;.$data-&amp;gt;access_token.&amp;#34;&amp;amp;openid=&amp;#34;.$data-&amp;gt;openid.&amp;#34;&amp;amp;lang=zh_CN&amp;#34;) 流程示例代码&#xA;public function oauth(){ if (isset($_GET[&amp;#39;code&amp;#39;])){ $data=json_decode(file_get_contents(&amp;#34;https://api.weixin.qq.com/sns/oauth2/access_token?appid=&amp;#34;.$this-&amp;gt;appid.&amp;#34;&amp;amp;secret=&amp;#34;.$this-&amp;gt;secret.&amp;#34;&amp;amp;code=&amp;#34;.$_GET[&amp;#39;code&amp;#39;].&amp;#34;&amp;amp;grant_type=authorization_code&amp;#34;)); $userInfo=json_decode(file_get_contents(&amp;#34;https://api.w eixin.qq.com/sns/userinfo?access_token=&amp;#34;.$data-&amp;gt;access_token.&amp;#34;&amp;amp;openid=&amp;#34;.$data-&amp;gt;openid.&amp;#34;&amp;amp;lang=zh_CN&amp;#34;)); $user = array( &amp;#39;openid&amp;#39; =&amp;gt; $userInfo-&amp;gt;openid, &amp;#39;nickname&amp;#39; =&amp;gt; $userInfo-&amp;gt;nickname, &amp;#39;headimgurl&amp;#39; =&amp;gt; $userInfo-&amp;gt;headimgurl ); $this-&amp;gt;session-&amp;gt;set_userdata($user); $this-&amp;gt;db-&amp;gt;replace(&amp;#39;user&amp;#39;, $user); redirect(&amp;#39;client&amp;#39;); }else{ echo &amp;#34;出现未知错误，如果重复出现该错误，请联系开发者。错误代码:Oauth:10203&amp;#34;; } } php密码操作(PHP 5 &amp;gt;= 5.5.0, PHP 7) 加密操作:string password_hash ( string $password , int $algo [, array $options ] ) 示例:&#xA;password_hash(&amp;#34;admin&amp;#34;, PASSWORD_DEFAULT); 判断操作: bool password_verify ( string $password , string $hash ) 示例:</description>
    </item>
  </channel>
</rss>
